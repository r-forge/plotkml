
R version 3.5.1 (2018-07-02) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "plotKML"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> base::assign(".ExTimings", "plotKML-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('plotKML')
plotKML version 0.5-9 (2019-01-04)
URL: http://plotkml.r-forge.r-project.org/
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("HRprec08")
> ### * HRprec08
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: HRprec08
> ### Title: Daily precipitation for Croatia for year 2008
> ### Aliases: HRprec08
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(HRprec08)
> library(sp)
> ## Not run: 
> ##D # subset:
> ##D prec.2008.05.01 <- HRprec08[HRprec08$DATE=="2008-05-01",]
> ##D coordinates(prec.2008.05.01) <- ~Lon+Lat
> ##D proj4string(prec.2008.05.01) <- CRS("+proj=lonlat +datum=WGS84")
> ##D # write to KML:
> ##D shape = "http://plotkml.r-forge.r-project.org/circle.png"
> ##D data(SAGA_pal)
> ##D kml(prec.2008.05.01, size = PREC, shape = shape, colour = PREC, 
> ##D     colour_scale = SAGA_pal[[9]], labels = PREC)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("HRprec08", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:sp’

> nameEx("HRtemp08")
> ### * HRtemp08
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: HRtemp08
> ### Title: Daily temperatures for Croatia for year 2008
> ### Aliases: HRtemp08
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(HRtemp08)
> 
> ## Not run: 
> ##D ## examples from: http://dx.doi.org/10.1007/s00704-011-0464-2 
> ##D library(spacetime)
> ##D library(gstat)
> ##D library(sp)
> ##D sp <- SpatialPoints(HRtemp08[,c("Lon","Lat")])
> ##D proj4string(sp) <- CRS("+proj=longlat +datum=WGS84")
> ##D HRtemp08.st <- STIDF(sp, time = HRtemp08$DATE-.5, 
> ##D      data = HRtemp08[,c("NAME","TEMP")], 
> ##D      endTime = as.POSIXct(HRtemp08$DATE+.5))
> ##D ## Country borders:
> ##D con0 <- url("http://www.gadm.org/data/rda/HRV_adm1.RData")
> ##D load(con0)
> ##D stplot(HRtemp08.st[,"2008-07-02::2008-07-03","TEMP"], 
> ##D    na.rm=TRUE, col.regions=SAGA_pal[[1]],
> ##D    sp.layout=list("sp.polygons", gadm))
> ##D 
> ##D ## Load covariates:
> ##D con <- url("http://plotkml.r-forge.r-project.org/HRgrid1km.rda")
> ##D load(con)
> ##D str(HRgrid1km)
> ##D sel.s <- c("HRdem","HRdsea","HRtwi","Lat","Lon")
> ##D ## Prepare static covariates:
> ##D begin <- as.Date("2008-01-01")  
> ##D endTime <- as.POSIXct(as.Date("2008-12-31"))
> ##D sp.grid <- as(HRgrid1km, "SpatialPixels")
> ##D HRgrid1km.st0 <- STFDF(sp.grid, time=begin, 
> ##D     data=HRgrid1km@data[,sel.s], endTime=endTime)
> ##D ## Prepare dynamic covariates:
> ##D sel.d <- which(!names(HRgrid1km) %in% sel.s)
> ##D dates <- sapply(names(HRgrid1km)[sel.d], 
> ##D      function(x){strsplit(x, "LST")[[1]][2]}
> ##D )
> ##D dates <- as.Date(dates, format="%Y_%m_%d")
> ##D ## Sort values of MODIS LST bands:
> ##D m <- data.frame(MODIS.LST = as.vector(unlist(HRgrid1km@data[,sel.d])))
> ##D ## >10M values!
> ##D ## Create an object of type STFDF:
> ##D HRgrid1km.stD <- STFDF(sp.grid, time=dates-4, data=m, 
> ##D      endTime=as.POSIXct(dates+4))
> ##D 
> ##D ## Overlay in space and time:
> ##D HRtemp08.stxy <- spTransform(HRtemp08.st, CRS(proj4string(HRgrid1km)))
> ##D ov.s <- over(HRtemp08.stxy, HRgrid1km.st0)
> ##D ov.d <- over(HRtemp08.stxy, HRgrid1km.stD)
> ##D ## Prepare the regression matrix:
> ##D regm <- do.call(cbind, list(HRtemp08.stxy@data, ov.s, ov.d))
> ##D ## Estimate cumulative days:
> ##D regm$cday <- floor(unclass(HRtemp08.stxy@endTime)/86400-.5)
> ##D str(regm)
> ##D ## Plot a single station:
> ##D scatter.smooth(regm$cday[regm$NAME=="Zavi<c5><be>an"], 
> ##D     regm$TEMP[regm$NAME=="Zavi<c5><be>an"], 
> ##D     xlab="Cumulative days", 
> ##D     ylab="Mean daily temperature (\260C)", 
> ##D     ylim=c(-12,28), main="GL039 (Zavi\236an)", 
> ##D     col="grey")
> ##D ## Run PCA so we can filter missing pixels in the MODIS images:
> ##D pca <- prcomp(~HRdem+HRdsea+Lat+Lon+HRtwi+MODIS.LST, 
> ##D     data=regm, scale.=TRUE)
> ##D selc <- c("TEMP","Lon","Lat","cday")
> ##D regm.pca <- cbind( regm[-pca$na.action, selc], 
> ##D     as.data.frame(pca$x))
> ##D ## Fit a spatio-temporal regression model:
> ##D theta <- min(regm.pca$cday)
> ##D lm.HRtemp08 <- lm(TEMP~PC1+PC2+PC3+PC4+PC5+PC6 
> ##D      +cos((cday-theta)*pi/180), data=regm.pca)
> ##D summary(lm.HRtemp08)
> ##D 
> ##D ## Prediction locations -> focus on Istria:
> ##D data(LST)
> ##D gridded(LST) <- ~lon+lat
> ##D proj4string(LST) <- CRS("+proj=longlat +datum=WGS84")
> ##D LST.xy <- reproject(LST[1], proj4string(HRgrid1km))
> ##D LST.xy <- as(LST.xy, "SpatialPixels")
> ##D ## targeted dates:
> ##D t.dates <- as.Date(c("2008-02-01","2008-05-01","2008-08-01"), 
> ##D      format="%Y-%m-%d")
> ##D LST.st <- STF(geometry(LST.xy), time=t.dates)
> ##D ## get values of covariates:
> ##D ov.s.IS <- over(LST.st, HRgrid1km.st0)
> ##D ov.d.IS <- over(LST.st, HRgrid1km.stD)
> ##D LST.stdf <- STFDF(geometry(LST.xy), time=t.dates, 
> ##D     data=cbind(ov.s.IS, ov.d.IS))
> ##D ## predict Principal Components:
> ##D LST.pca <- as.data.frame(predict(pca, LST.stdf@data))
> ##D LST.stdf@data[,paste0("PC",1:6)] <- LST.pca
> ##D cday.l <- as.vector(sapply(
> ##D     floor(unclass(LST.stdf@endTime)/86400-.5), 
> ##D     rep, nrow(LST.xy@coords)))
> ##D LST.stdf@data[,"cday"] <- cday.l
> ##D stplot(LST.stdf[,,"PC1"], col.regions=SAGA_pal[[1]])
> ##D stplot(LST.stdf[,,"PC2"], col.regions=SAGA_pal[[1]])
> ##D 
> ##D ## Predict spatio-temporal regression:
> ##D LST.stdf@data[,"TEMP.reg"] <- predict(lm.HRtemp08, 
> ##D      newdata=LST.stdf@data)
> ##D ## Plot predictions:
> ##D gadm.ll <- as(spTransform(gadm, 
> ##D      CRS(proj4string(HRgrid1km))), "SpatialLines")
> ##D stplot(LST.stdf[,,"TEMP.reg"], col.regions=SAGA_pal[[1]],
> ##D   sp.layout=list( list("sp.lines", gadm.ll),
> ##D    list("sp.points", HRtemp08.stxy, col="black", pch=19) )
> ##D   )
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("HRtemp08", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("RasterBrickSimulations")
> ### * RasterBrickSimulations
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: RasterBrickSimulations-class
> ### Title: A class for spatial simulations containing equiprobable gridded
> ###   features
> ### Aliases: RasterBrickSimulations-class plotKML,RasterBrickSimulations
> ### Keywords: classes
> 
> ### ** Examples
>  
> ## Not run: 
> ##D # load input data:
> ##D data(barxyz)
> ##D # define the projection system:
> ##D prj = "+proj=tmerc +lat_0=0 +lon_0=18 +k=0.9999 +x_0=6500000 +y_0=0 +ellps=bessel +units=m 
> ##D +towgs84=550.499,164.116,475.142,5.80967,2.07902,-11.62386,0.99999445824"
> ##D library(sp)
> ##D coordinates(barxyz) <- ~x+y
> ##D proj4string(barxyz) <- CRS(prj)
> ##D data(bargrid)
> ##D coordinates(bargrid) <- ~x+y
> ##D gridded(bargrid) <- TRUE
> ##D proj4string(bargrid) <- CRS(prj)
> ##D # fit a variogram and generate simulations:
> ##D library(gstat)
> ##D Z.ovgm <- vgm(psill=1352, model="Mat", range=650, nugget=0, kappa=1.2)
> ##D sel <- runif(length(barxyz$Z))<.2  # Note: this operation can be time consuming
> ##D sims <- krige(Z~1, barxyz[sel,], bargrid, model=Z.ovgm, nmax=20, nsim=10, debug.level=-1) 
> ##D # specify the cross-section:
> ##D t1 <- Line(matrix(c(bargrid@bbox[1,1],bargrid@bbox[1,2],5073012,5073012), ncol=2))
> ##D transect <- SpatialLines(list(Lines(list(t1), ID="t")), CRS(prj))
> ##D # glue to a RasterBrickSimulations object:
> ##D bardem_sims <- new("RasterBrickSimulations", variable = "elevations", 
> ##D   sampled = transect, realizations = brick(sims))
> ##D # plot the whole project and open in Google Earth:
> ##D data(R_pal)
> ##D plotKML(bardem_sims, colour_scale = R_pal[[4]])
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("RasterBrickSimulations", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("SAGA_pal")
> ### * SAGA_pal
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: SAGA_pal
> ### Title: Colour palettes for numeric variables
> ### Aliases: color_palettes SAGA_pal R_pal
> ### Keywords: color datasets
> 
> ### ** Examples
> 
> data(SAGA_pal)
> data(R_pal)
> ## Not run: 
> ##D # visualize SAGA GIS palettes:
> ##D display.pal(pal=SAGA_pal, sel=c(1,2,7,8,10,11,17,18,19,21,22))
> ##D dev.off()
> ##D display.pal(R_pal)
> ##D names(R_pal)
> ##D dev.off()
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("SAGA_pal", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("SpatialMetadata")
> ### * SpatialMetadata
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: SpatialMetadata-class
> ### Title: A class for spatial metadata
> ### Aliases: SpatialMetadata-class summary,SpatialMetadata-method
> ###   GetPalette,SpatialMetadata-method GetPalette
> ###   GetNames,SpatialMetadata-method GetNames
> ### Keywords: classes
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(eberg)
> ##D library(sp)
> ##D coordinates(eberg) <- ~X+Y
> ##D proj4string(eberg) <- CRS("+init=epsg:31467")
> ##D names(eberg)
> ##D # add metadata:
> ##D eberg.md <- spMetadata(eberg, xml.file=system.file("eberg.xml", package="plotKML"), 
> ##D     Target_variable="SNDMHT_A")
> ##D p <- GetPalette(eberg.md)
> ##D str(p)
> ##D x <- summary(eberg.md)
> ##D str(x)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("SpatialMetadata", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("SpatialVectorsSimulations")
> ### * SpatialVectorsSimulations
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: SpatialVectorsSimulations-class
> ### Title: A class for spatial simulations containing equiprobable line,
> ###   point or polygon features
> ### Aliases: SpatialVectorsSimulations-class
> ###   plotKML,SpatialVectorsSimulations
> ### Keywords: classes
> 
> ### ** Examples
>  
> ## load a list of equiprobable streams:
> data(barstr)
> data(bargrid)
> library(sp)
> coordinates(bargrid) <- ~ x+y
> gridded(bargrid) <- TRUE
> ## output topology:
> cell.size = bargrid@grid@cellsize[1]
> bbox = bargrid@bbox
> nrows = round(abs(diff(bbox[1,])/cell.size), 0) 
> ncols = round(abs(diff(bbox[2,])/cell.size), 0)
> gridT = GridTopology(cellcentre.offset=bbox[,1], cellsize=c(cell.size,cell.size), 
+   cells.dim=c(nrows, ncols))
> ## Not run: 
> ##D ## derive summaries (observed frequency and the entropy or error):
> ##D bar_sum <- count.GridTopology(gridT, vectL=barstr[1:5]) 
> ##D ## NOTE: this operation can be time consuming!
> ##D ## plot the whole project and open in Google Earth:
> ##D plotKML(bar_sum, grid2poly = TRUE)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("SpatialVectorsSimulations", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:sp’

> nameEx("baranja")
> ### * baranja
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: baranja
> ### Title: Baranja hill case study
> ### Aliases: barxyz bargrid barstr
> ### Keywords: datasets
> 
> ### ** Examples
> 
> library(sp)
> library(gstat)
> ## sampled elevations:
> data(barxyz)
> prj = "+proj=tmerc +lat_0=0 +lon_0=18 +k=0.9999 +x_0=6500000 +y_0=0 +ellps=bessel +units=m 
+ +towgs84=550.499,164.116,475.142,5.80967,2.07902,-11.62386,0.99999445824"
> coordinates(barxyz) <- ~x+y
> proj4string(barxyz) <- CRS(prj)
> ## grids:
> data(bargrid)
> data(barstr)
> coordinates(bargrid) <- ~x+y
> gridded(bargrid) <- TRUE
> proj4string(bargrid) <- barxyz@proj4string
> bargrid@grid
                        x       y
cellcentre.offset 6551894 5070570
cellsize               30      30
cells.dim             123     124
> ## Not run: 
> ##D ## Example with simulated streams:
> ##D data(R_pal)
> ##D library(rgdal)
> ##D library(RSAGA)
> ##D pnt = list("sp.points", barxyz, col="black", pch="+")
> ##D spplot(bargrid[1], sp.layout=pnt, 
> ##D   col.regions = R_pal[["blue_grey_red"]])
> ##D ## Deriving stream networks using geostatistical simulations:
> ##D Z.ovgm <- vgm(psill=1831, model="Mat", range=1051, nugget=0, kappa=1.2)
> ##D sel <- runif(length(barxyz$Z))<.2
> ##D N.sim <- 5
> ##D ## geostatistical simulations:
> ##D DEM.sim <- krige(Z~1, barxyz[sel,], bargrid, model=Z.ovgm, nmax=20, 
> ##D    nsim=N.sim, debug.level=-1)
> ##D ## Note: this operation can be time consuming
> ##D 
> ##D stream.list <- list(rep(NA, N.sim))
> ##D ## derive stream networks in SAGA GIS:
> ##D for (i in 1:N.sim) {
> ##D   writeGDAL(DEM.sim[i], paste("DEM", i, ".sdat", sep=""), 
> ##D      drivername = "SAGA", mvFlag = -99999)
> ##D   ## filter the spurious sinks:
> ##D   rsaga.fill.sinks(in.dem=paste("DEM", i, ".sgrd", sep=""), 
> ##D      out.dem="DEMflt.sgrd", check.module.exists = FALSE)
> ##D   ## extract the channel network SAGA GIS:
> ##D   rsaga.geoprocessor(lib="ta_channels", module=0, 
> ##D     param=list(ELEVATION="DEMflt.sgrd", 
> ##D     CHNLNTWRK=paste("channels", i, ".sgrd", sep=""), 
> ##D     CHNLROUTE="channel_route.sgrd", 
> ##D     SHAPES="channels.shp", 
> ##D     INIT_GRID="DEMflt.sgrd", 
> ##D     DIV_CELLS=3, MINLEN=40),
> ##D     check.module.exists = FALSE, 
> ##D     show.output.on.console=FALSE)
> ##D   stream.list[[i]] <- readOGR("channels.shp", "channels", 
> ##D     verbose=FALSE)
> ##D   proj4string(stream.list[[i]]) <- barxyz@proj4string
> ##D }
> ##D # plot all derived streams at top of each other:
> ##D streams.plot <- as.list(rep(NA, N.sim))
> ##D for(i in 1:N.sim){
> ##D   streams.plot[[i]] <- list("sp.lines", stream.list[[i]])
> ##D }
> ##D spplot(DEM.sim[1], col.regions=grey(seq(0.4,1,0.025)), scales=list(draw=T), 
> ##D sp.layout=streams.plot)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("baranja", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:gstat’, ‘package:sp’

> nameEx("bigfoot")
> ### * bigfoot
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: bigfoot
> ### Title: Bigfoot reports (USA)
> ### Aliases: bigfoot USAWgrids
> ### Keywords: datasets
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Load the BFRO records:
> ##D library(sp)
> ##D data(bigfoot)
> ##D aea.prj <- "+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 
> ##D +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs"
> ##D library(sp)
> ##D coordinates(bigfoot) <- ~Lon+Lat
> ##D proj4string(bigfoot) <- CRS("+proj=latlon +datum=WGS84")
> ##D library(rgdal)
> ##D bigfoot.aea <- spTransform(bigfoot, CRS(aea.prj))
> ##D # Load the covariates:
> ##D data(USAWgrids)
> ##D gridded(USAWgrids) <- ~s1+s2
> ##D proj4string(USAWgrids) <- CRS(aea.prj)
> ##D # Visualize data:
> ##D data(SAGA_pal)
> ##D pnts <- list("sp.points", bigfoot.aea, pch="+", col="yellow")
> ##D spplot(USAWgrids[2], col.regions=rev(SAGA_pal[[3]]), sp.layout=pnts)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("bigfoot", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("check_projection")
> ### * check_projection
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: check_projection
> ### Title: Extracts the proj4 parameters and checks if the projection
> ###   matches the referent CRS
> ### Aliases: check_projection parse_proj4 extractProjValue
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(eberg)
> library(sp)
> library(rgdal)
rgdal: version: 1.3-3, (SVN revision 759)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 2.2.3, released 2017/11/20
 Path to GDAL shared files: /usr/share/gdal/2.2
 GDAL binary built with GEOS: TRUE 
 Loaded PROJ.4 runtime: Rel. 4.9.3, 15 August 2016, [PJ_VERSION: 493]
 Path to PROJ.4 shared files: (autodetected)
 Linking to sp version: 1.3-1 
> coordinates(eberg) <- ~X+Y
> proj4string(eberg) <- CRS("+init=epsg:31467")
> check_projection(eberg)
[1] FALSE
> # not yet ready for export to KML;
> parse_proj4(proj4string(eberg))
     proj     datum 
  "tmerc" "potsdam" 
> eberg.geo <- reproject(eberg)
Reprojecting to +proj=longlat +datum=WGS84 ...
> check_projection(eberg.geo)
[1] TRUE
> # ... now ready for export
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("check_projection", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:rgdal’, ‘package:sp’

> nameEx("col2kml")
> ### * col2kml
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: col2kml
> ### Title: Convert a color strings to the KML format
> ### Aliases: col2kml hex2kml kml2hex munsell2kml
> ### Keywords: color
> 
> ### ** Examples
> 
> col2kml("white")
[1] "#ffffffff"
> col2kml(colors()[2])
[1] "#fffff8f0"
> hex2kml(rgb(1,1,1))
[1] "#ffffffff"
> x <- munsell2kml("10YR", "2", "4")
> kml2hex(x)
[1] "#6F5F4CFF"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("col2kml", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("display.pal")
> ### * display.pal
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: display.pal
> ### Title: Display a color palette
> ### Aliases: display.pal
> ### Keywords: spatial
> 
> ### ** Examples
> 
> # SAGA GIS palette (http://saga-gis.org/en/about/software.html)
> data(SAGA_pal)
> names(SAGA_pal)
 [1] "SG_COLORS_DEFAULT"         "SG_COLORS_DEFAULT_BRIGHT" 
 [3] "SG_COLORS_WHITE_BLACK"     "SG_COLORS_RED_BLACK"      
 [5] "SG_COLORS_GREEN_BLACK"     "SG_COLORS_BLUE_BLACK"     
 [7] "SG_COLORS_WHITE_RED"       "SG_COLORS_WHITE_GREEN"    
 [9] "SG_COLORS_WHITE_BLUE"      "SG_COLORS_YELLOW_RED"     
[11] "SG_COLORS_YELLOW_GREEN"    "SG_COLORS_YELLOW_BLUE"    
[13] "SG_COLORS_GREEN_RED"       "SG_COLORS_BLUE_RED"       
[15] "SG_COLORS_BLUE_GREEN"      "SG_COLORS_BLUE_GREY_RED"  
[17] "SG_COLORS_GREEN_GREY_RED"  "SG_COLORS_BLUE_GREY_GREEN"
[19] "SG_COLORS_BLUE_GREEN_RED"  "SG_COLORS_RED_BLUE_GREEN" 
[21] "SG_COLORS_GREEN_RED_BLUE"  "SG_COLORS_RAINBOW"        
> ## Not run: 
> ##D # display palettes:
> ##D display.pal(pal=SAGA_pal, sel=c(1,2,7,8,10,11,17,18,19,21,22))
> ##D dev.off()
> ##D data(worldgrids_pal)
> ##D worldgrids_pal[["globcov"]]
> ##D display.pal(pal=worldgrids_pal, sel=c(5), names = TRUE)
> ##D dev.off()
> ##D # make icons (http://www.statmethods.net/advgraphs/parameters.html):
> ##D for(i in 0:25){
> ##D   png(filename=paste("icon", i, ".png", sep=""), width=45, height=45, 
> ##D   bg="transparent", pointsize=16)
> ##D   par(mar=c(0,0,0,0))
> ##D   plot(x=1, y=1, axes=FALSE, xlab='', ylab='', pch=i, cex=4, lwd=2)
> ##D   dev.off()
> ##D }
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("display.pal", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eberg")
> ### * eberg
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eberg
> ### Title: Ebergotzen - soil mapping case study
> ### Aliases: eberg eberg_grid eberg_grid25 eberg_zones eberg_contours
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(eberg)
> data(eberg_grid)
> data(eberg_zones)
> data(eberg_contours)
> library(sp)
> coordinates(eberg) <- ~X+Y
> proj4string(eberg) <- CRS("+init=epsg:31467")
> gridded(eberg_grid) <- ~x+y
> proj4string(eberg_grid) <- CRS("+init=epsg:31467")
> # visualize the maps:
> data(SAGA_pal)
> l.sp <- list("sp.lines", eberg_contours, col="black")
> ## Not run: 
> ##D spplot(eberg_grid["DEMSRT6"], col.regions = SAGA_pal[[1]], sp.layout=l.sp)
> ##D spplot(eberg_zones, sp.layout=list("sp.points", eberg, col="black", pch="+"))
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eberg", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:sp’

> nameEx("geopath")
> ### * geopath
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: geopath
> ### Title: Geopath - shortest trajectory line between two geographic
> ###   locations
> ### Aliases: geopath
> ### Keywords: spatial
> 
> ### ** Examples
> 
> library(fossil)
Loading required package: sp
Loading required package: maps
Loading required package: shapefiles
Loading required package: foreign

Attaching package: ‘shapefiles’

The following objects are masked from ‘package:foreign’:

    read.dbf, write.dbf

> ams.ny <- geopath(lon1=4.892222, lon2=-74.005973, lat1=52.373056, lat2=40.714353, 
+   print.geo=TRUE)
[1] "Distance: 5863.8"
[1] "Bearing: 290.8"
> # write to a file:
> kml(ams.ny)
KML file opened for writing...
Writing to KML...
Closing  ams.ny.kml
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("geopath", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:fossil’, ‘package:shapefiles’, ‘package:foreign’,
  ‘package:maps’, ‘package:sp’

> nameEx("getCRS")
> ### * getCRS
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: getCRS-methods
> ### Title: Methods to get the proj4 string
> ### Aliases: getCRS getCRS.Raster getCRS.Spatial getCRS,Raster-method
> ###   getCRS,Spatial-method
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
> data(eberg_grid)
> library(sp)
> coordinates(eberg_grid) <- ~x+y
> gridded(eberg_grid) <- TRUE
> library(rgdal)
rgdal: version: 1.3-3, (SVN revision 759)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 2.2.3, released 2017/11/20
 Path to GDAL shared files: /usr/share/gdal/2.2
 GDAL binary built with GEOS: TRUE 
 Loaded PROJ.4 runtime: Rel. 4.9.3, 15 August 2016, [PJ_VERSION: 493]
 Path to PROJ.4 shared files: (autodetected)
 Linking to sp version: 1.3-1 
> proj4string(eberg_grid) <- CRS("+init=epsg:31467")
> library(raster)
> r <- raster(eberg_grid[1])
> getCRS(r)
[1] "+init=epsg:31467 +proj=tmerc +lat_0=0 +lon_0=9 +k=1 +x_0=3500000 +y_0=0 +datum=potsdam +units=m +no_defs +ellps=bessel +towgs84=598.1,73.7,418.2,0.202,0.045,-2.455,6.7"
> r.ll <- reproject(r)
Reprojecting to +proj=longlat +datum=WGS84 ...
> getCRS(r.ll)
[1] "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("getCRS", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:raster’, ‘package:rgdal’, ‘package:sp’

> nameEx("getWikimedia")
> ### * getWikimedia
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: getWikiMedia.ImageInfo
> ### Title: Gets EXIF information
> ### Aliases: getWikiMedia.ImageInfo
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Photo taken using a GPS-enabled camera:
> ##D imagename = "Africa_Museum_Nijmegen.jpg"
> ##D x <- getWikiMedia.ImageInfo(imagename)
> ##D # Get the GPS info:
> ##D x$metadata[grep(names(x$metadata), pattern="GPS")]
> ##D # prints the complete list of metadata tags;
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("getWikimedia", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("gpxbtour")
> ### * gpxbtour
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: gpxbtour
> ### Title: GPS log of a bike tour
> ### Aliases: gpxbtour trajectory
> ### Keywords: datasets
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## load the data:
> ##D data(gpxbtour)
> ##D library(sp)
> ##D ## format the time column:
> ##D gpxbtour$ctime <- as.POSIXct(gpxbtour$time, format="%Y-%m-%dT%H:%M:%SZ")
> ##D coordinates(gpxbtour) <- ~lon+lat
> ##D proj4string(gpxbtour) <- CRS("+proj=longlat +datum=WGS84")
> ##D ## convert to a STTDF class:
> ##D library(spacetime)
> ##D library(adehabitatLT)
> ##D gpx.ltraj <- as.ltraj(coordinates(gpxbtour), gpxbtour$ctime, id = "th")
> ##D gpx.st <- as(gpx.ltraj, "STTDF")
> ##D ## Google maps plot:
> ##D library(RgoogleMaps)
> ##D llc <- c(mean(gpx.st@sp@bbox[2,]), mean(gpx.st@sp@bbox[1,]))
> ##D MyMap <- GetMap.bbox(center=llc, zoom=8, destfile="map.png")
> ##D PlotOnStaticMap(MyMap, lat=gpx.st@sp@coords[,2], lon=gpx.st@sp@coords[,1], 
> ##D   FUN=lines, col="black", lwd=4)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("gpxbtour", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("grid2poly")
> ### * grid2poly
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: grid2poly
> ### Title: Converts a gridded map to a polygon map
> ### Aliases: grid2poly
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(eberg_grid)
> library(sp)
> coordinates(eberg_grid) <- ~x+y
> gridded(eberg_grid) <- TRUE
> proj4string(eberg_grid) <- CRS("+init=epsg:31467")
> data(SAGA_pal)
> ## Not run: 
> ##D # compare various methods:
> ##D system.time(dem_poly <- grid2poly(eberg_grid, "DEMSRT6", method = "raster"))
> ##D system.time(dem_poly <- grid2poly(eberg_grid, "DEMSRT6", method = "sp"))
> ##D system.time(dem_poly <- grid2poly(eberg_grid, "DEMSRT6", method = "RSAGA"))
> ##D ## plotting large polygons in R -> not a good idea
> ##D # spplot(dem_poly, col.regions = SAGA_pal[[1]])
> ##D ## visualize the data in Google Earth:
> ##D kml(dem_poly, colour_scale = SAGA_pal[[1]], colour = DEMSRT6, kmz = TRUE)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("grid2poly", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:sp’

> nameEx("kml")
> ### * kml
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: kml-methods
> ### Title: Write to a KML file
> ### Aliases: kml kml-methods plotKML.fileIO kml.Spatial kml,Raster-method
> ###   kml,STIDF-method kml,SoilProfileCollection-method kml,Spatial-method
> ###   kml,SpatialPhotoOverlay-method
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
> # Plotting a SpatialPointsDataFrame object
> library(rgdal)
Loading required package: sp
rgdal: version: 1.3-3, (SVN revision 759)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 2.2.3, released 2017/11/20
 Path to GDAL shared files: /usr/share/gdal/2.2
 GDAL binary built with GEOS: TRUE 
 Loaded PROJ.4 runtime: Rel. 4.9.3, 15 August 2016, [PJ_VERSION: 493]
 Path to PROJ.4 shared files: (autodetected)
 Linking to sp version: 1.3-1 
> data(eberg)
> eberg <- eberg[runif(nrow(eberg))<.1,]
> library(sp)
> library(rgdal)
> coordinates(eberg) <- ~X+Y
> proj4string(eberg) <- CRS("+init=epsg:31467")
> ## Not run: 
> ##D # Simple plot
> ##D kml(eberg, file = "eberg-0.kml")
> ##D # Plot using aesthetics
> ##D shape = "http://maps.google.com/mapfiles/kml/pal2/icon18.png"
> ##D kml(eberg, colour = SNDMHT_A, size = CLYMHT_A, 
> ##D    alpha = 0.75, file = "eberg-1.kml", shape=shape)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("kml", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:rgdal’, ‘package:sp’

> nameEx("kml.tiles")
> ### * kml.tiles
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: kml.tiles
> ### Title: Write vector object as tiled KML
> ### Aliases: kml.tiles
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(sp)
> ##D library(snowfall)
> ##D library(GSIF)
> ##D library(rgdal)
> ##D 
> ##D data(eberg)
> ##D coordinates(eberg) <- ~X+Y
> ##D proj4string(eberg) <- CRS("+init=epsg:31467")
> ##D ## plot using tiles:
> ##D shape = "http://maps.google.com/mapfiles/kml/pal2/icon18.png"
> ##D tiles.p <- kml.tiles(eberg["SNDMHT_A"], block.x=0.05, 
> ##D    size=0.8, z.lim=c(20,50), colour=SNDMHT_A, shape=shape, 
> ##D    labels=SNDMHT_A, return.list=TRUE)
> ##D ## Returns a list of tiles
> ##D data(eberg_contours)
> ##D tiles.l <- kml.tiles(eberg_contours, block.x=0.05, 
> ##D    colour=Z, z.lim=range(eberg_contours$Z), 
> ##D    colour_scale=SAGA_pal[[1]], return.list=TRUE)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("kml.tiles", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("kml_compress")
> ### * kml_compress
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: kml_compress
> ### Title: Compress a KML file with auxiliary files
> ### Aliases: kml_compress
> ### Keywords: utilities
> 
> ### ** Examples
> 
> data(eberg)
> eberg <- eberg[runif(nrow(eberg))<.1,] 
> library(sp)
> library(rgdal)
rgdal: version: 1.3-3, (SVN revision 759)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 2.2.3, released 2017/11/20
 Path to GDAL shared files: /usr/share/gdal/2.2
 GDAL binary built with GEOS: TRUE 
 Loaded PROJ.4 runtime: Rel. 4.9.3, 15 August 2016, [PJ_VERSION: 493]
 Path to PROJ.4 shared files: (autodetected)
 Linking to sp version: 1.3-1 
> library(raster)
> coordinates(eberg) <- ~X+Y
> proj4string(eberg) <- CRS("+init=epsg:31467")
> kml_open("eberg.kml")
KML file opened for writing...
> kml_layer(eberg, colour = CLYMHT_A)
Reprojecting to +proj=longlat +datum=WGS84 ...
Writing to KML...
> kml_close("eberg.kml")
Closing  eberg.kml
> # compress:
> kml_compress("eberg.kml")
  adding: data/git/plotkml/www/plotKML.Rcheck/eberg.kml (deflated 97%)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("kml_compress", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:raster’, ‘package:rgdal’, ‘package:sp’

> nameEx("kml_layer")
> ### * kml_layer
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: kml_layer-methods
> ### Title: Write objects to a KML connection
> ### Aliases: kml_layer kml_alpha kml_altitude kml_altitude_mode kml_colour
> ###   kml_shape kml_size kml_layer,RasterBrick-method
> ###   kml_layer,RasterLayer-method kml_layer,RasterStack-method
> ###   kml_layer,STIDF-method kml_layer,STFDF-method kml_layer,STSDF-method
> ###   kml_layer,STTDF-method kml_layer,SoilProfileCollection-method
> ###   kml_layer,SpatialGrid-method kml_layer,SpatialLines-method
> ###   kml_layer,SpatialPhotoOverlay-method kml_layer,SpatialPixels-method
> ###   kml_layer,SpatialPoints-method kml_layer,SpatialPolygons-method
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
> library(rgdal)
Loading required package: sp
rgdal: version: 1.3-3, (SVN revision 759)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 2.2.3, released 2017/11/20
 Path to GDAL shared files: /usr/share/gdal/2.2
 GDAL binary built with GEOS: TRUE 
 Loaded PROJ.4 runtime: Rel. 4.9.3, 15 August 2016, [PJ_VERSION: 493]
 Path to PROJ.4 shared files: (autodetected)
 Linking to sp version: 1.3-1 
> data(eberg_grid)
> library(sp)
> library(raster)
> gridded(eberg_grid) <- ~x+y
> proj4string(eberg_grid) <- CRS("+init=epsg:31467")
> data(SAGA_pal)
> data(R_pal)
> ## Not run: 
> ##D # Plot two layers one after the other:
> ##D kml_open("eberg_grids.kml")
> ##D kml_layer(eberg_grid, colour=DEMSRT6, colour_scale=R_pal[["terrain_colors"]])
> ##D kml_layer(eberg_grid, colour=TWISRT6, colour_scale=SAGA_pal[[1]])
> ##D kml_close("eberg_grids.kml")
> ##D # print the result:
> ##D library(XML)
> ##D xmlRoot(xmlTreeParse("eberg_grids.kml"))[["Document"]]
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("kml_layer", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:raster’, ‘package:rgdal’, ‘package:sp’

> nameEx("kml_screen")
> ### * kml_screen
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: kml_screen
> ### Title: Add a screen overlay
> ### Aliases: kml_screen
> 
> ### ** Examples
> 
> library(rgdal)
Loading required package: sp
rgdal: version: 1.3-3, (SVN revision 759)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 2.2.3, released 2017/11/20
 Path to GDAL shared files: /usr/share/gdal/2.2
 GDAL binary built with GEOS: TRUE 
 Loaded PROJ.4 runtime: Rel. 4.9.3, 15 August 2016, [PJ_VERSION: 493]
 Path to PROJ.4 shared files: (autodetected)
 Linking to sp version: 1.3-1 
> library(sp)
> data(eberg_zones)
> ## Not run: 
> ##D # add logo in the top-center:
> ##D kml_open("eberg_screen.kml")
> ##D kml_layer(eberg_zones)
> ##D logo = "http://meta.isric.org/images/ISRIC_right.png"
> ##D kml_screen(image.file = logo, position = "TC", sname = "ISRIC logo")
> ##D kml_close("eberg_screen.kml")
> ##D kml_compress("eberg_screen.kml")
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("kml_screen", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:rgdal’, ‘package:sp’

> nameEx("layer.Raster")
> ### * layer.Raster
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: kml_layer.Raster
> ### Title: Writes raster objects to KML
> ### Aliases: kml_layer.Raster RasterLayer
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(eberg_grid)
> library(sp)
> coordinates(eberg_grid) <- ~x+y
> gridded(eberg_grid) <- TRUE
> proj4string(eberg_grid) <- CRS("+init=epsg:31467")
> data(SAGA_pal)
> library(raster)
> r <- raster(eberg_grid["TWISRT6"])
> ## Not run: 
> ##D # KML plot with a single raster:
> ##D kml(r, colour_scale = SAGA_pal[[1]], colour = TWISRT6) 
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("layer.Raster", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:raster’, ‘package:sp’

> nameEx("layer.STIDF")
> ### * layer.STIDF
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: kml_layer.STIDF
> ### Title: Write irregular spatio-temporal observations (points, lines and
> ###   polygons) to KML
> ### Aliases: kml_layer.STIDF kml_layer.STFDF STIDF
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(HRtemp08)
> ##D 
> ##D # format the time column:
> ##D HRtemp08$ctime <- as.POSIXct(HRtemp08$DATE, format="%Y-%m-%dT%H:%M:%SZ")
> ##D 
> ##D # create a STIDF object:
> ##D library(spacetime)
> ##D sp <- SpatialPoints(HRtemp08[,c("Lon","Lat")])
> ##D proj4string(sp) <- CRS("+proj=longlat +datum=WGS84")
> ##D HRtemp08.st <- STIDF(sp, time = HRtemp08$ctime, data = HRtemp08[,c("NAME","TEMP")])
> ##D 
> ##D # write to a KML file:
> ##D HRtemp08_jan <- HRtemp08.st[1:500]
> ##D shape <- "http://maps.google.com/mapfiles/kml/pal2/icon18.png"
> ##D kml(HRtemp08_jan, dtime = 24*3600, colour = TEMP, shape = shape, labels = "", kmz=TRUE)
> ##D 
> ##D ## North Carolina SIDS data set:
> ##D library(maptools)
> ##D fname <- system.file("shapes/sids.shp", package="maptools")[1]
> ##D nc <- readShapePoly(fname, proj4string=CRS("+proj=longlat +datum=NAD27"))
> ##D time <- as.POSIXct(strptime(c(rep("1974-01-01", length(nc)), 
> ##D    rep("1979-01-01", length(nc))), format="%Y-%m-%d"), tz = "GMT")
> ##D data <- data.frame(BIR = c(nc$BIR74, nc$BIR79), NWBIR = c(nc$NWBIR74, nc$NWBIR79), 
> ##D    SID = c(nc$SID74, nc$SID79))
> ##D # copy polygons:
> ##D nc.poly <- rep(slot(nc, "polygons"), 2)
> ##D # fix the polygon IDs:
> ##D for(i in 1:length(row.names(data))) { nc.poly[[i]]@ID = row.names(data)[i] }
> ##D sp <- SpatialPolygons(nc.poly, proj4string=CRS("+proj=longlat +datum=NAD27"))
> ##D # create a STIDF object:
> ##D nct <- STIDF(sp, time = time, data = data)
> ##D # write to a KML file:
> ##D kml(nct, colour = SID)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("layer.STIDF", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("layer.SoilProfileCollection")
> ### * layer.SoilProfileCollection
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: kml_layer.SoilProfileCollection
> ### Title: Writes a list of soil profiles to KML
> ### Aliases: kml_layer.SoilProfileCollection SoilProfileCollection
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## install.packages("aqp", repos="http://R-Forge.R-project.org")
> ##D library(aqp)
> ##D library(fossil)
> ##D library(plyr)
> ##D data(ca630)
> ##D ## Promote to SoilProfileCollection
> ##D ca <- join(ca630$lab, ca630$site, type='inner')
> ##D depths(ca) <- pedon_key ~ hzn_top + hzn_bot
> ##D ## extract site data
> ##D site(ca) <- ~ mlra + ssa + lon + lat + cntrl_depth_to_top + cntrl_depth_to_bot + sampled_taxon_name
> ##D # generate SpatialPoints
> ##D library(sp)
> ##D coordinates(ca) <- ~ lon + lat
> ##D ## assign CRS data
> ##D proj4string(ca) <- "+proj=longlat +datum=NAD83"
> ##D ## plot changes in base saturation by sum of cations method (pH 8.2):
> ##D kml(ca, method = "depth_function", file.name = "ca_bs_8_2.kml", 
> ##D   var.name="bs_8.2", balloon = TRUE)
> ##D ## plot changes in cation exchange capacity by sum of cations method (pH 8.2):
> ##D kml(ca, file.name = "ca_CEC8_2.kml", var.name="CEC8.2", IconColor = "#ff009000")
> ##D ## plot soil profile as 'block':
> ##D kml(ca, file.name = "ca_CEC8_2_block.kml", var.name="CEC8.2", balloon = TRUE)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("layer.SoilProfileCollection", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("layer.SpatialLines")
> ### * layer.SpatialLines
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: kml_layer.SpatialLines
> ### Title: Writes spatial lines to KML
> ### Aliases: kml_layer.SpatialLines SpatialLines
> ### Keywords: spatial
> 
> ### ** Examples
> 
> library(rgdal)
Loading required package: sp
rgdal: version: 1.3-3, (SVN revision 759)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 2.2.3, released 2017/11/20
 Path to GDAL shared files: /usr/share/gdal/2.2
 GDAL binary built with GEOS: TRUE 
 Loaded PROJ.4 runtime: Rel. 4.9.3, 15 August 2016, [PJ_VERSION: 493]
 Path to PROJ.4 shared files: (autodetected)
 Linking to sp version: 1.3-1 
> library(sp)
> data(eberg_contours)
> data(SAGA_pal)
> names(eberg_contours)
[1] "ID" "Z" 
> # KML plot with elevations used as 'colour' argument:
> kml(eberg_contours, colour_scale = SAGA_pal[[1]], colour = Z, kmz = TRUE)
KML file opened for writing...
Reprojecting to +proj=longlat +datum=WGS84 ...
Writing to KML...
Closing  eberg_contours.kml
  adding: data/git/plotkml/www/plotKML.Rcheck/eberg_contours.kml (deflated 68%)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("layer.SpatialLines", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:rgdal’, ‘package:sp’

> nameEx("layer.SpatialPhotoOverlay")
> ### * layer.SpatialPhotoOverlay
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: kml_layer.SpatialPhotoOverlay
> ### Title: Exports objects of type SpatialPhotoOverlay to KML
> ### Aliases: kml_layer.SpatialPhotoOverlay
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # display spatially referenced photograph in Google Earth:
> ##D imagename = "Soil_monolith.jpg"
> ##D x1 <- getWikiMedia.ImageInfo(imagename)
> ##D sm <- spPhoto(filename = x1$url$url, exif.info = x1$metadata)
> ##D kml_open("sm.kml")
> ##D kml_layer(sm, method="monolith")
> ##D kml_close("sm.kml")
> ##D kml_compress("sm.kml", files="Soil_monolith_jpg.dae")
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("layer.SpatialPhotoOverlay", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("layer.SpatialPixels")
> ### * layer.SpatialPixels
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: kml_layer.SpatialPixels
> ### Title: Writes SpatialPixels or SpatialGrid objects to KML
> ### Aliases: kml_layer.SpatialPixels SpatialPixels
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(eberg_grid)
> library(sp)
> library(rgdal)
rgdal: version: 1.3-3, (SVN revision 759)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 2.2.3, released 2017/11/20
 Path to GDAL shared files: /usr/share/gdal/2.2
 GDAL binary built with GEOS: TRUE 
 Loaded PROJ.4 runtime: Rel. 4.9.3, 15 August 2016, [PJ_VERSION: 493]
 Path to PROJ.4 shared files: (autodetected)
 Linking to sp version: 1.3-1 
> library(raster)
> coordinates(eberg_grid) <- ~x+y
> gridded(eberg_grid) <- TRUE
> proj4string(eberg_grid) <- CRS("+init=epsg:31467")
> data(SAGA_pal)
> ## Not run: 
> ##D ## KML plot with a single raster:
> ##D kml(eberg_grid, colour_scale = SAGA_pal[[1]], colour = TWISRT6)
> ##D ## make a larger image:
> ##D kml(eberg_grid, colour_scale = SAGA_pal[[1]], colour = TWISRT6, 
> ##D   png.width = 600, png.height = 600)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("layer.SpatialPixels", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:raster’, ‘package:rgdal’, ‘package:sp’

> nameEx("layer.SpatialPoints")
> ### * layer.SpatialPoints
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: kml_layer.SpatialPoints
> ### Title: Writes spatial points to KML
> ### Aliases: kml_layer.SpatialPoints SpatialPoints
> ### Keywords: spatial
> 
> ### ** Examples
> 
> data(eberg)
> data(SAGA_pal)
> library(sp)
> library(rgdal)
rgdal: version: 1.3-3, (SVN revision 759)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 2.2.3, released 2017/11/20
 Path to GDAL shared files: /usr/share/gdal/2.2
 GDAL binary built with GEOS: TRUE 
 Loaded PROJ.4 runtime: Rel. 4.9.3, 15 August 2016, [PJ_VERSION: 493]
 Path to PROJ.4 shared files: (autodetected)
 Linking to sp version: 1.3-1 
> coordinates(eberg) <- ~X+Y
> proj4string(eberg) <- CRS("+init=epsg:31467")
> names(eberg)
 [1] "ID"       "soiltype" "TAXGRSC"  "UHDICM_A" "LHDICM_A" "SNDMHT_A"
 [7] "SLTMHT_A" "CLYMHT_A" "UHDICM_B" "LHDICM_B" "SNDMHT_B" "SLTMHT_B"
[13] "CLYMHT_B" "UHDICM_C" "LHDICM_C" "SNDMHT_C" "SLTMHT_C" "CLYMHT_C"
[19] "UHDICM_D" "LHDICM_D" "SNDMHT_D" "SLTMHT_D" "CLYMHT_D" "UHDICM_E"
[25] "LHDICM_E" "SNDMHT_E" "SLTMHT_E" "CLYMHT_E"
> # subset to 10 percent:
> eberg <- eberg[runif(nrow(eberg))<.1,]
> ## Not run: 
> ##D # plot the measured CLAY content:
> ##D kml(eberg, labels = CLYMHT_A)
> ##D shape = "http://maps.google.com/mapfiles/kml/pal2/icon18.png"
> ##D # color only:
> ##D kml(eberg, shape = shape, colour = SLTMHT_A, labels = "", colour_scale = SAGA_pal[[1]])
> ##D # two variables at the same time:
> ##D kml(eberg, shape = shape, size = CLYMHT_A, colour = SLTMHT_A, labels = "")
> ##D # two aesthetics elements are effective in emphasizing hot-spots:
> ##D kml(eberg, shape = shape, altitude = CLYMHT_A*10, extrude = TRUE, 
> ##D   colour = CLYMHT_A, labels = CLYMHT_A, kmz = TRUE)
> ## End(Not run)
> 
> ## example of how plotKML is programmed:
> data(HRtemp08)
> HRtemp08[1,]
      NAME      Lat      Lon       DATE TEMP
1 Bilogora 45.88512 17.20566 2008-02-18 2.35
> library(XML)
> p1 = newXMLNode("Placemark")
> begin <- format(HRtemp08[1,"DATE"]-.5, "%Y-%m-%dT%H:%M:%SZ")
> end <- format(HRtemp08[1,"DATE"]+.5, "%Y-%m-%dT%H:%M:%SZ")
> txt <- sprintf('<name>%s</name><TimeStamp><begin>%s</begin><end>%s</end></TimeStamp>
+     <Point><coordinates>%.4f,%.4f,%.0f</coordinates></Point>', HRtemp08[1,"NAME"], 
+     begin, end, HRtemp08[1,"Lon"], HRtemp08[1,"Lat"], 0)
> parseXMLAndAdd(txt, parent=p1)
> p1
<Placemark>
  <name>Bilogora</name>
  <TimeStamp>
    <begin>2008-02-17T00:00:00Z</begin>
    <end>2008-02-18T00:00:00Z</end>
  </TimeStamp>
  <Point>
    <coordinates>17.2057,45.8851,0</coordinates>
  </Point>
</Placemark> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("layer.SpatialPoints", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:XML’, ‘package:rgdal’, ‘package:sp’

> nameEx("layer.SpatialPolygons")
> ### * layer.SpatialPolygons
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: kml_layer.SpatialPolygons
> ### Title: Writes spatial polygons to KML
> ### Aliases: kml_layer.SpatialPolygons SpatialPolygons
> ### Keywords: spatial
> 
> ### ** Examples
> 
> library(rgdal)
Loading required package: sp
rgdal: version: 1.3-3, (SVN revision 759)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 2.2.3, released 2017/11/20
 Path to GDAL shared files: /usr/share/gdal/2.2
 GDAL binary built with GEOS: TRUE 
 Loaded PROJ.4 runtime: Rel. 4.9.3, 15 August 2016, [PJ_VERSION: 493]
 Path to PROJ.4 shared files: (autodetected)
 Linking to sp version: 1.3-1 
> library(sp)
> data(eberg_zones)
> names(eberg_zones)
[1] "ZONES"
> ## visualize zones using random colors:
> kml(eberg_zones, colorMode = "random")
KML file opened for writing...
Reprojecting to +proj=longlat +datum=WGS84 ...
Writing to KML...
Closing  eberg_zones.kml
> ## with labels:
> kml(eberg_zones, colour = ZONES, plot.labpt = TRUE, 
+    labels = ZONES, kmz = TRUE, balloon=TRUE)
KML file opened for writing...
Reprojecting to +proj=longlat +datum=WGS84 ...
Writing to KML...
Closing  eberg_zones.kml
  adding: data/git/plotkml/www/plotKML.Rcheck/eberg_zones.kml (deflated 77%)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("layer.SpatialPolygons", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:rgdal’, ‘package:sp’

> nameEx("legend.whitening")
> ### * legend.whitening
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: kml_legend.whitening
> ### Title: Whitening legend (PNG)
> ### Aliases: kml_legend.whitening
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # create the 2D legend for whitening (PNG file):
> ##D kml_legend.whitening(x.lim=c(5,20), e.lim=c(.6,1))
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("legend.whitening", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("makeCOLLADA")
> ### * makeCOLLADA
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: makeCOLLADA
> ### Title: Generate a COLLADA file representing the 3D model of a rectangle
> ### Aliases: makeCOLLADA makeCOLLADA.rectangle
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # image previously uploaded to Wikimedia commons:
> ##D imagename = "Soil_monolith.jpg"
> ##D x1 <- getWikiMedia.ImageInfo(imagename)
> ##D sm <- spPhoto(filename = x1$url$url, exif.info = x1$metadata)
> ##D kml(sm, method="monolith")
> ##D xmlTreeParse("Soil_monolith_jpg.dae")
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("makeCOLLADA", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("metadata2SLD.SpatialPixels")
> ### * metadata2SLD.SpatialPixels
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: metadata2SLD.SpatialPixels
> ### Title: Writes a Styled Layer Description (*SLD*) file
> ### Aliases: metadata2SLD.SpatialPixels
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # generate missing metadata
> ##D data(eberg_grid)
> ##D library(sp)
> ##D coordinates(eberg_grid) <- ~x+y
> ##D gridded(eberg_grid) <- TRUE
> ##D proj4string(eberg_grid) <- CRS("+init=epsg:31467")
> ##D # with localy prepared metadata file:
> ##D eberg_TWI <- as(eberg_grid["TWISRT6"], "SpatialPixelsDataFrame")
> ##D eberg.md <- spMetadata(eberg_TWI, Target_variable="TWISRT6")
> ##D # export to SLD format:
> ##D metadata2SLD(eberg.md, "eberg_TWI.sld")
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("metadata2SLD.SpatialPixels", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("normalizeFilename")
> ### * normalizeFilename
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: normalizeFilename
> ### Title: Normalize filename string
> ### Aliases: normalizeFilename
> ### Keywords: utilities
> 
> ### ** Examples
> 
> normalizeFilename("name[%].txt")
[1] "name_%_.txt"
> normalizeFilename("name .txt")
[1] "name_.txt"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("normalizeFilename", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plotKML.GDALobj")
> ### * plotKML.GDALobj
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plotKML.GDALobj
> ### Title: Write tiled objects to KML
> ### Aliases: plotKML.GDALobj
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(sp)
> ##D library(snowfall)
> ##D library(GSIF)
> ##D library(rgdal)
> ##D fn = system.file("pictures/SP27GTIF.TIF", 
> ##D  package = "rgdal")
> ##D obj <- GDALinfo(fn)
> ##D tiles <- getSpatialTiles(obj, block.x=5000, 
> ##D   return.SpatialPolygons = FALSE)
> ##D ## plot using tiles:
> ##D plotKML.GDALobj(obj, tiles=tiles, z.lim=c(0,185))
> ##D ## Even better ideas is to first reproject 
> ##D ## the large grid using 'gdalUtils::gdalwarp', then tile...
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plotKML.GDALobj", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plotKML")
> ### * plotKML
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plotKML-method
> ### Title: Methods for plotting results of spatial analysis in Google Earth
> ### Aliases: plotKML-method plotKML plotKML,SpatialPointsDataFrame-method
> ###   plotKML,SpatialLinesDataFrame-method
> ###   plotKML,SpatialPolygonsDataFrame-method
> ###   plotKML,SoilProfileCollection-method
> ###   plotKML,SpatialGridDataFrame-method
> ###   plotKML,SpatialPixelsDataFrame-method plotKML,RasterLayer-method
> ###   plotKML,SpatialPhotoOverlay-method plotKML,STIDF-method
> ###   plotKML,STFDF-method plotKML,STSDF-method plotKML,STTDF-method
> ###   plotKML,SpatialPredictions-method
> ###   plotKML,RasterBrickSimulations-method
> ###   plotKML,SpatialVectorsSimulations-method
> ###   plotKML,SpatialMaxEntOutput-method
> ###   plotKML,RasterBrickTimeSeries-method
> ###   plotKML,SpatialSamplingPattern-method plotKML,list-method
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
> plotKML.env(kmz = FALSE)
$colour_scale_numeric
[1] "#2C7BB6" "#ABD9E9" "#FFFFBF" "#FDAE61" "#D7191C"

$colour_scale_factor
[1] "#E41A1C" "#377EB8" "#4DAF4A" "#984EA3" "#FF7F00" "#FFFF33" "#A65628"
[8] "#F781BF" "#999999"

$colour_scale_svar
[1] "#FEEDDE" "#FDBE85" "#FD8D3C" "#E6550D" "#A63603"

$ref_CRS
[1] "+proj=longlat +datum=WGS84"

$NAflag
[1] -99999

$icon
[1] "icon3.png"

$LabelScale
[1] 0.5

$size_range
[1] 0.25 2.50

$license_url
[1] "http://creativecommons.org/licenses/by/3.0/"

$metadata_sel
 [1] "idinfo.citation.citeinfo.title"                                       
 [2] "idinfo.descript.abstract"                                             
 [3] "spdoinfo.ptvctinf.sdtsterm.ptvctcnt"                                  
 [4] "idinfo.timeperd.timeinfo.rngdates.begdate"                            
 [5] "idinfo.timeperd.timeinfo.rngdates.enddate"                            
 [6] "distinfo.stdorder.digform.digtopt.onlinopt.computer.networka.networkr"
 [7] "idinfo.citation.citeinfo.othercit"                                    
 [8] "idinfo.citation.citeinfo.onlink"                                      
 [9] "idinfo.datacred"                                                      
[10] "distinfo.distrib.cntinfo.cntorgp.cntorg"                              
[11] "distinfo.stdorder.digform.digtinfo.formcont"                          
[12] "idinfo.native"                                                        

$kmz
[1] FALSE

$kml_xsd
[1] "http://schemas.opengis.net/kml/2.2.0/ogckml22.xsd"

$kml_url
[1] "http://www.opengis.net/kml/2.2/"

$kml_gx
[1] "http://www.google.com/kml/ext/2.2"

$gpx_xsd
[1] "http://www.topografix.com/GPX/1/1/gpx.xsd"

$fgdc_xsd
[1] "http://fgdcxml.sourceforge.net/schema/fgdc-std-012-2002/fgdc-std-012-2002.xsd"

$inspire_xsd
[1] "http://inspire.ec.europa.eu/schemas/common/1.0/common.xsd"

$convert
[1] ""

$gdalwarp
[1] ""

$gdal_translate
[1] ""

$python
[1] ""

$home_url
[1] "http://plotkml.r-forge.r-project.org/"

> ## -------------- SpatialPointsDataFrame --------- ##
> library(sp)
> library(rgdal)
rgdal: version: 1.3-3, (SVN revision 759)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 2.2.3, released 2017/11/20
 Path to GDAL shared files: /usr/share/gdal/2.2
 GDAL binary built with GEOS: TRUE 
 Loaded PROJ.4 runtime: Rel. 4.9.3, 15 August 2016, [PJ_VERSION: 493]
 Path to PROJ.4 shared files: (autodetected)
 Linking to sp version: 1.3-1 
> data(eberg)
> coordinates(eberg) <- ~X+Y
> proj4string(eberg) <- CRS("+init=epsg:31467")
> ## subset to 20 percent:
> eberg <- eberg[runif(nrow(eberg))<.1,]
> ## Not run: 
> ##D ## bubble type plot:
> ##D plotKML(eberg["CLYMHT_A"])
> ##D plotKML(eberg["CLYMHT_A"], colour_scale=rep("#FFFF00", 2), points_names="")
> ## End(Not run)
> ## plot points with a legend:
> shape = "http://maps.google.com/mapfiles/kml/pal2/icon18.png" 
> kml_open("eberg_CLYMHT_A.kml")
KML file opened for writing...
> kml_layer(eberg["CLYMHT_A"], colour=CLYMHT_A, z.lim=c(20,60),
+    colour_scale=SAGA_pal[[1]], shape=shape, points_names="")
Reprojecting to +proj=longlat +datum=WGS84 ...
Writing to KML...
> kml_legend.bar(x=eberg$CLYMHT_A, legend.file="kml_legend.png",
+    legend.pal=SAGA_pal[[1]], z.lim=c(20,60))
pdf 
  2 
> kml_screen(image.file="kml_legend.png")
> kml_close("eberg_CLYMHT_A.kml")
Closing  eberg_CLYMHT_A.kml
> 
> ## -------------- SpatialLinesDataFrame --------- ##
> data(eberg_contours)
> ## Not run: 
> ##D plotKML(eberg_contours)
> ##D ## plot contour lines with actual altitudes:
> ##D plotKML(eberg_contours, colour=Z, altitude=Z)
> ## End(Not run)
> 
> ## -------------- SpatialPolygonsDataFrame --------- ##
> data(eberg_zones)
> ## Not run: 
> ##D plotKML(eberg_zones["ZONES"])
> ##D ## add altitude:
> ##D zmin = 230
> ##D plotKML(eberg_zones["ZONES"], altitude=zmin+runif(length(eberg_zones))*500)
> ## End(Not run)
> 
> ## -------------- SpatialPixelsDataFrame --------- ##
> library(rgdal)
> library(raster)
> data(eberg_grid)
> gridded(eberg_grid) <- ~x+y
> proj4string(eberg_grid) <- CRS("+init=epsg:31467")
> TWI <- reproject(eberg_grid["TWISRT6"])
Reprojecting to +proj=longlat +datum=WGS84 ...
> data(SAGA_pal)
> ## Not run: 
> ##D ## set limits manually (increase resolution):
> ##D plotKML(TWI, colour_scale = SAGA_pal[[1]])
> ##D plotKML(TWI, z.lim=c(12,20), colour_scale = SAGA_pal[[1]])
> ## End(Not run)
> ## categorical data:
> eberg_grid$LNCCOR6 <- as.factor(paste(eberg_grid$LNCCOR6))
> levels(eberg_grid$LNCCOR6)
[1] "112 - Discontinuous urban fabric"   "211 - Non-irrigated arable land"   
[3] "231 - Pastures"                     "242 - Complex cultivation patterns"
[5] "311 - Broad-leaved forest"          "312 - Coniferous forest"           
[7] "313 - Mixed forest"                
> data(worldgrids_pal)
> ## attr(worldgrids_pal["corine2k"][[1]], "names")
> pal = as.character(worldgrids_pal["corine2k"][[1]][c(1,11,13,14,16,17,18)])
> LNCCOR6 <- reproject(eberg_grid["LNCCOR6"])
Reprojecting to +proj=longlat +datum=WGS84 ...
> ## Not run: 
> ##D plotKML(LNCCOR6, colour_scale=pal)
> ## End(Not run)
> 
> ## -------------- SpatialPhotoOverlay --------- ##
> ## Not run: 
> ##D library(RCurl)
> ##D imagename = "Soil_monolith.jpg"
> ##D urlExists = url.exists("http://commons.wikimedia.org")
> ##D if(urlExists){
> ##D   x1 <- getWikiMedia.ImageInfo(imagename)
> ##D   sm <- spPhoto(filename = x1$url$url, exif.info = x1$metadata)
> ##D   # str(sm)
> ##D   plotKML(sm)
> ##D }
> ## End(Not run)
> 
> ## -------------- SoilProfileCollection --------- ##
> library(aqp)
This is aqp 1.16

Attaching package: ‘aqp’

The following objects are masked from ‘package:raster’:

    metadata, metadata<-

> library(plyr)
> ## sample profile from Nigeria:
> lon = 3.90; lat = 7.50; id = "ISRIC:NG0017"; FAO1988 = "LXp" 
> top = c(0, 18, 36, 65, 87, 127) 
> bottom = c(18, 36, 65, 87, 127, 181)
> ORCDRC = c(18.4, 4.4, 3.6, 3.6, 3.2, 1.2)
> hue = c("7.5YR", "7.5YR", "2.5YR", "5YR", "5YR", "10YR")
> value = c(3, 4, 5, 5, 5, 7); chroma = c(2, 4, 6, 8, 4, 3)
> ## prepare a SoilProfileCollection:
> prof1 <- join(data.frame(id, top, bottom, ORCDRC, hue, value, chroma), 
+    data.frame(id, lon, lat, FAO1988), type='inner')
Joining by: id
> prof1$soil_color <- with(prof1, munsell2rgb(hue, value, chroma))
Notice: converting hue to character
> depths(prof1) <- id ~ top + bottom
Warning: converting IDs from factor to character
> site(prof1) <- ~ lon + lat + FAO1988 
> coordinates(prof1) <- ~ lon + lat
> proj4string(prof1) <- CRS("+proj=longlat +datum=WGS84")
> prof1
Object of class SoilProfileCollection
Number of profiles: 1

Horizon attributes:
            id top bottom ORCDRC   hue value chroma soil_color
1 ISRIC:NG0017   0     18   18.4 7.5YR     3      2  #584537FF
2 ISRIC:NG0017  18     36    4.4 7.5YR     4      4  #7E5A3BFF
3 ISRIC:NG0017  36     65    3.6 2.5YR     5      6  #A96C4FFF
4 ISRIC:NG0017  65     87    3.6   5YR     5      8  #B06A32FF
5 ISRIC:NG0017  87    127    3.2   5YR     5      4  #9A7359FF
6 ISRIC:NG0017 127    181    1.2  10YR     7      3  #C4AC8CFF

Sampling site attributes:
            id FAO1988
1 ISRIC:NG0017     LXp

Spatial Data:
    min max
lon 3.9 3.9
lat 7.5 7.5
[1] "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"
> ## Not run: 
> ##D plotKML(prof1, var.name="ORCDRC", color.name="soil_color")
> ## End(Not run)
> 
> ## -------------- STIDF --------- ##
> library(sp)
> library(spacetime)
> ## daily temperatures for Croatia:
> data(HRtemp08)
> ## format the time column:
> HRtemp08$ctime <- as.POSIXct(HRtemp08$DATE, format="%Y-%m-%dT%H:%M:%SZ")
> ## create a STIDF object:
> sp <- SpatialPoints(HRtemp08[,c("Lon","Lat")])
> proj4string(sp) <- CRS("+proj=longlat +datum=WGS84")
> HRtemp08.st <- STIDF(sp, time = HRtemp08$ctime, data = HRtemp08[,c("NAME","TEMP")])
> ## subset to first 500 records:
> HRtemp08_jan <- HRtemp08.st[1:500]
> str(HRtemp08_jan)
Formal class 'STIDF' [package "spacetime"] with 4 slots
  ..@ data   :'data.frame':	500 obs. of  2 variables:
  .. ..$ NAME: Factor w/ 158 levels "<c3><88>akovec",..: 17 50 81 83 84 82 85 86 88 89 ...
  .. ..$ TEMP: num [1:500] -3.5 -1.25 -4 NA 2.58 ...
  ..@ sp     :Formal class 'SpatialPoints' [package "sp"] with 3 slots
  .. .. ..@ coords     : num [1:500, 1:2] 17.2 15.6 17.4 15.5 13.6 ...
  .. .. .. ..- attr(*, "dimnames")=List of 2
  .. .. .. .. ..$ : NULL
  .. .. .. .. ..$ : chr [1:2] "Lon" "Lat"
  .. .. ..@ bbox       : num [1:2, 1:2] 13.6 42.4 19.4 46.4
  .. .. .. ..- attr(*, "dimnames")=List of 2
  .. .. .. .. ..$ : chr [1:2] "Lon" "Lat"
  .. .. .. .. ..$ : chr [1:2] "min" "max"
  .. .. ..@ proj4string:Formal class 'CRS' [package "sp"] with 1 slot
  .. .. .. .. ..@ projargs: chr "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"
  ..@ time   :An ‘xts’ object on 2008-01-01 01:00:00/2008-01-04 01:00:00 containing:
  Data: int [1:500, 1] 298 433 916 1198 1683 2010 2526 2932 2966 3327 ...
 - attr(*, "dimnames")=List of 2
  ..$ : NULL
  ..$ : chr "timeIndex"
  Indexed by objects of class: [POSIXct,POSIXt] TZ: 
  xts Attributes:  
 NULL
  ..@ endTime: POSIXct[1:500], format: "2008-01-01 01:00:00" "2008-01-01 01:00:00" ...
> ## Not run: 
> ##D plotKML(HRtemp08_jan[,,"TEMP"], LabelScale = .4)
> ## End(Not run)
> 
> ## foot-and-mouth disease data:
> data(fmd)
> fmd0  <- data.frame(fmd)
> coordinates(fmd0) <- c("X", "Y")
> proj4string(fmd0) <- CRS("+init=epsg:27700")
> fmd_sp <- as(fmd0, "SpatialPoints")
> dates <- as.Date("2001-02-18")+fmd0$ReportedDay
> library(spacetime)
> fmd_ST <- STIDF(fmd_sp, dates, data.frame(ReportedDay=fmd0$ReportedDay))
> data(SAGA_pal)
> ## Not run: 
> ##D plotKML(fmd_ST, colour_scale=SAGA_pal[[1]])
> ## End(Not run)
> 
> ## -------------- STFDF --------- ##
> 
> ## results of krigeST:
> library(gstat)
> library(sp)
> library(spacetime)
> library(raster)
> ## define space-time variogram
> sumMetricVgm <- vgmST("sumMetric",
+                       space=vgm( 4.4, "Lin", 196.6,  3),
+                       time =vgm( 2.2, "Lin",   1.1,  2),
+                       joint=vgm(34.6, "Exp", 136.6, 12),
+                       stAni=51.7)
> ## example from the gstat package:
> data(air)
> rural = STFDF(stations, dates, data.frame(PM10 = as.vector(air)))
> rr <- rural[,"2005-06-01/2005-06-03"]
> rr <- as(rr,"STSDF")
> x1 <- seq(from=6,to=15,by=1)
> x2 <- seq(from=48,to=55,by=1)
> DE_gridded <- SpatialPoints(cbind(rep(x1,length(x2)), rep(x2,each=length(x1))), 
+                            proj4string=CRS(proj4string(rr@sp)))
> gridded(DE_gridded) <- TRUE
> DE_pred <- STF(sp=as(DE_gridded,"SpatialPoints"), time=rr@time)
> DE_kriged <- krigeST(PM10~1, data=rr, newdata=DE_pred,
+                      modelList=sumMetricVgm)
Warning in krigeST(PM10 ~ 1, data = rr, newdata = DE_pred, modelList = sumMetricVgm) :
  The spatio-temporal variogram model does not carry a time unit attribute: krisgeST cannot check whether the temporal distance metrics coincide.
> gridded(DE_kriged@sp) <- TRUE
> stplot(DE_kriged)
> ## plot in Google Earth:
> z.lim = range(DE_kriged@data, na.rm=TRUE)
> ## Not run: 
> ##D plotKML(DE_kriged, z.lim=z.lim)
> ##D ## add observations points:
> ##D plotKML(rr, z.lim=z.lim)
> ## End(Not run)
> 
> ## -------------- STTDF --------- ##
> ## Not run: 
> ##D library(fossil)
> ##D library(spacetime)
> ##D library(adehabitatLT)
> ##D data(gpxbtour)
> ##D ## format the time column:
> ##D gpxbtour$ctime <- as.POSIXct(gpxbtour$time, format="%Y-%m-%dT%H:%M:%SZ")
> ##D coordinates(gpxbtour) <- ~lon+lat
> ##D proj4string(gpxbtour) <- CRS("+proj=longlat +datum=WGS84")
> ##D xy <- as.list(data.frame(t(coordinates(gpxbtour))))
> ##D gpxbtour$dist.km <- sapply(xy, function(x) { 
> ##D   deg.dist(long1=x[1], lat1=x[2], long2=xy[[1]][1], lat2=xy[[1]][2]) 
> ##D } )
> ##D ## convert to a STTDF class:
> ##D gpx.ltraj <- as.ltraj(coordinates(gpxbtour), gpxbtour$ctime, id = "th")
> ##D gpx.st <- as(gpx.ltraj, "STTDF")
> ##D gpx.st$speed <- gpxbtour$speed
> ##D gpx.st@sp@proj4string <- CRS("+proj=longlat +datum=WGS84")
> ##D str(gpx.st)
> ##D plotKML(gpx.st, colour="speed")
> ## End(Not run)
> 
> ## -------------- Spatial Metadata --------- ##
> ## Not run: 
> ##D eberg.md <- spMetadata(eberg, xml.file=system.file("eberg.xml", package="plotKML"),
> ##D   Target_variable="SNDMHT_A", Citation_title="Ebergotzen profiles")
> ##D plotKML(eberg[1:100,"CLYMHT_A"], metadata=eberg.md)
> ## End(Not run)
> 
> ## -------------- RasterBrickTimeSeries --------- ##
> library(raster)
> library(sp)
> data(LST)
> gridded(LST) <- ~lon+lat
> proj4string(LST) <- CRS("+proj=longlat +datum=WGS84")
> dates <- sapply(strsplit(names(LST), "LST"), function(x){x[[2]]})
> datesf <- format(as.Date(dates, "%Y_%m_%d"), "%Y-%m-%dT%H:%M:%SZ")
> ## begin / end dates +/- 4 days:
> TimeSpan.begin = as.POSIXct(unclass(as.POSIXct(datesf))-4*24*60*60, origin="1970-01-01") 
> TimeSpan.end = as.POSIXct(unclass(as.POSIXct(datesf))+4*24*60*60, origin="1970-01-01")
> ## pick climatic stations in the area:
> pnts <- HRtemp08[which(HRtemp08$NAME=="Pazin")[1],]
> pnts <- rbind(pnts, HRtemp08[which(HRtemp08$NAME=="Crni Lug - NP Risnjak")[1],])
> pnts <- rbind(pnts, HRtemp08[which(HRtemp08$NAME=="Cres")[1],])
> coordinates(pnts) <- ~Lon + Lat
> proj4string(pnts) <- CRS("+proj=longlat +datum=WGS84")
> ## get the dates from the file names:
> LST_ll <- brick(LST[1:5])
> LST_ll@title = "Time series of MODIS Land Surface Temperature images"
> LST.ts <- new("RasterBrickTimeSeries", variable = "LST", sampled = pnts, 
+     rasters = LST_ll, TimeSpan.begin = TimeSpan.begin[1:5], 
+     TimeSpan.end = TimeSpan.end[1:5])
> data(SAGA_pal)
> ## Not run: 
> ##D ## plot MODIS images in Google Earth:
> ##D plotKML(LST.ts, colour_scale=SAGA_pal[[1]])
> ## End(Not run)
> 
> ## -------------- Spatial Predictions --------- ##
> library(sp)
> library(rgdal)
> library(gstat)
> data(meuse)
> coordinates(meuse) <- ~x+y
> proj4string(meuse) <- CRS("+init=epsg:28992")
> ## load grids:
> data(meuse.grid)
> gridded(meuse.grid) <- ~x+y
> proj4string(meuse.grid) <- CRS("+init=epsg:28992")
> ## Not run: 
> ##D ## fit a model:
> ##D library(GSIF)
> ##D omm <- fit.gstatModel(observations = meuse, formulaString = om~dist, 
> ##D    family = gaussian(log), covariates = meuse.grid)
> ##D ## produce SpatialPredictions:
> ##D om.rk <- predict(omm, predictionLocations = meuse.grid)
> ##D ## plot the whole geostatical mapping project in Google Earth:
> ##D plotKML(om.rk, colour_scale = SAGA_pal[[1]])
> ##D ## plot each cell as polygon:
> ##D plotKML(om.rk, colour_scale = SAGA_pal[[1]], grid2poly = TRUE)
> ## End(Not run)
> 
> ## -------------- SpatialSamplingPattern --------- ##
> ## Not run: 
> ##D library(spcosa)
> ##D library(sp)
> ##D ## read a polygon map:
> ##D shpFarmsum <- readOGR(dsn = system.file("maps", package = "spcosa"), 
> ##D   layer = "farmsum")
> ##D ## stratify `Farmsum' into 50 strata
> ##D myStratification <- stratify(shpFarmsum, nStrata = 50)
> ##D ## sample two sampling units per stratum
> ##D mySamplingPattern <- spsample(myStratification, n = 2)
> ##D ## attach the correct proj4 string:
> ##D library(RCurl)
> ##D urlExists = url.exists("http://spatialreference.org/ref/sr-org/6781/proj4/")
> ##D if(urlExists){
> ##D   nl.rd <- getURL("http://spatialreference.org/ref/sr-org/6781/proj4/")
> ##D   proj4string(mySamplingPattern@sample) <- CRS(nl.rd) 
> ##D   # prepare spatial domain (polygons):
> ##D   sp.domain <- as(myStratification@cells, "SpatialPolygons")
> ##D   sp.domain <- SpatialPolygonsDataFrame(sp.domain, 
> ##D      data.frame(ID=as.factor(myStratification@stratumId)), match.ID = FALSE)
> ##D   proj4string(sp.domain) <- CRS(nl.rd) 
> ##D   # create new object:
> ##D   mySamplingPattern.ssp <- new("SpatialSamplingPattern", 
> ##D      method = class(mySamplingPattern), pattern = mySamplingPattern@sample, 
> ##D      sp.domain = sp.domain)
> ##D   # the same plot now in Google Earth:
> ##D   shape = "http://maps.google.com/mapfiles/kml/pal2/icon18.png"
> ##D   plotKML(mySamplingPattern.ssp, shape = shape)
> ##D }
> ## End(Not run)
> 
> ## -------------- RasterBrickSimulations --------- ##
> ## Not run: 
> ##D library(sp)
> ##D library(gstat)
> ##D data(barxyz)
> ##D ## define the projection system:
> ##D prj = "+proj=tmerc +lat_0=0 +lon_0=18 +k=0.9999 +x_0=6500000 +y_0=0 
> ##D   +ellps=bessel +units=m 
> ##D   +towgs84=550.499,164.116,475.142,5.80967,2.07902,-11.62386,0.99999445824"
> ##D coordinates(barxyz) <- ~x+y
> ##D proj4string(barxyz) <- CRS(prj)
> ##D data(bargrid)
> ##D coordinates(bargrid) <- ~x+y
> ##D gridded(bargrid) <- TRUE
> ##D proj4string(bargrid) <- CRS(prj)
> ##D ## fit a variogram and generate simulations:
> ##D Z.ovgm <- vgm(psill=1352, model="Mat", range=650, nugget=0, kappa=1.2)
> ##D sel <- runif(length(barxyz$Z))<.2  
> ##D ## Note: this operation can be time consuming
> ##D sims <- krige(Z~1, barxyz[sel,], bargrid, model=Z.ovgm, nmax=20, 
> ##D    nsim=10, debug.level=-1)
> ##D ## specify the cross-section:
> ##D t1 <- Line(matrix(c(bargrid@bbox[1,1], bargrid@bbox[1,2], 5073012, 5073012), ncol=2))
> ##D transect <- SpatialLines(list(Lines(list(t1), ID="t")), CRS(prj))
> ##D ## glue to a RasterBrickSimulations object:
> ##D library(raster)
> ##D bardem_sims <- new("RasterBrickSimulations", variable = "elevations", 
> ##D   sampled = transect, realizations = brick(sims))
> ##D ## plot the whole project and open in Google Earth:
> ##D data(R_pal)
> ##D plotKML(bardem_sims, colour_scale = R_pal[[4]])
> ## End(Not run)
> 
> ## -------------- SpatialVectorsSimulations --------- ##
> ## Not run: 
> ##D data(barstr)
> ##D data(bargrid)
> ##D library(sp)
> ##D coordinates(bargrid) <- ~ x+y
> ##D gridded(bargrid) <- TRUE
> ##D ## output topology:
> ##D cell.size = bargrid@grid@cellsize[1]
> ##D bbox = bargrid@bbox
> ##D nrows = round(abs(diff(bbox[1,])/cell.size), 0) 
> ##D ncols = round(abs(diff(bbox[2,])/cell.size), 0)
> ##D gridT = GridTopology(cellcentre.offset=bbox[,1], 
> ##D   cellsize=c(cell.size,cell.size), 
> ##D   cells.dim=c(nrows, ncols))
> ##D bar_sum <- count.GridTopology(gridT, vectL=barstr[1:5])
> ##D ## NOTE: this operation can be time consuming!
> ##D ## plot the whole project and open in Google Earth:
> ##D plotKML(bar_sum)
> ## End(Not run)
> 
> ## -------------- SpatialMaxEntOutput --------- ##
> ## Not run: 
> ##D library(maptools)
> ##D library(rgdal)
> ##D data(bigfoot)
> ##D aea.prj <- "+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 
> ##D    +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs"
> ##D data(USAWgrids)
> ##D gridded(USAWgrids) <- ~s1+s2
> ##D proj4string(USAWgrids) <- CRS(aea.prj)
> ##D bbox <- spTransform(USAWgrids, CRS("+proj=longlat +datum=WGS84"))@bbox
> ##D sel = bigfoot$Lon > bbox[1,1] & bigfoot$Lon < bbox[1,2] &
> ##D     bigfoot$Lat > bbox[2,1] & bigfoot$Lat < bbox[2,2]
> ##D bigfoot <- bigfoot[sel,]
> ##D coordinates(bigfoot) <- ~Lon+Lat
> ##D proj4string(bigfoot) <- CRS("+proj=longlat +datum=WGS84")
> ##D library(spatstat)
> ##D bigfoot.aea <- as.ppp(spTransform(bigfoot, CRS(aea.prj)))
> ##D ## Load the covariates:
> ##D sel.grids <- c("globedem","nlights03","sdroads","gcarb","twi","globcov")
> ##D library(GSIF)
> ##D library(dismo)
> ##D ## run MaxEnt analysis:
> ##D jar <- paste(system.file(package="dismo"), "/java/maxent.jar", sep='')
> ##D if(file.exists(jar)){
> ##D   bigfoot.smo <- MaxEnt(bigfoot.aea, USAWgrids[sel.grids])
> ##D   icon = "http://plotkml.r-forge.r-project.org/bigfoot.png"
> ##D   data(R_pal)
> ##D   plotKML(bigfoot.smo, colour_scale = R_pal[["bpy_colors"]], shape = icon)
> ##D }
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plotKML", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:gstat’, ‘package:spacetime’, ‘package:plyr’,
  ‘package:aqp’, ‘package:raster’, ‘package:rgdal’, ‘package:sp’

> nameEx("plotKML.env")
> ### * plotKML.env
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plotKML.env
> ### Title: plotKML specific environmental variables / paths
> ### Aliases: plotKML.env paths plotKML.opts
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## look for paths:
> ##D library(gdalUtils)
> ##D pts <- paths()
> ##D pts
> ##D plotKML.env(silent = FALSE)
> ##D gdalwarp <- get("gdalwarp", envir = plotKML.opts)
> ##D ## if missing you need to install it!
> ##D system(paste(gdalwarp, "--help-general")) 
> ##D system(paste(gdalwarp, "--formats"), intern = TRUE)
> ## End(Not run)
> plotKML.env(show.env = FALSE)
> get("home_url", envir = plotKML.opts)
[1] "http://plotkml.r-forge.r-project.org/"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plotKML.env", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("readGPX")
> ### * readGPX
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: readGPX
> ### Title: Import GPX (GPS track) files
> ### Aliases: readGPX
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # read GPX file from web:
> ##D fells_loop <- readGPX("http://www.topografix.com/fells_loop.gpx")
> ##D str(fells_loop)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("readGPX", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("readKML.GBIFdensity")
> ### * readKML.GBIFdensity
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: readKML.GBIFdensity
> ### Title: Imports GBIF cell density records
> ### Aliases: readKML.GBIFdensity
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # reading taxon density maps:
> ##D kml.file <- "taxon-celldensity-2294100.kml"
> ##D # download.file(paste("http://data.gbif.org/occurrences/taxon/celldensity/", kml.file, sep=""),
> ##D # destfile=paste(getwd(), kml.file, sep="")) 
> ##D # this will not run (you must first accept the data usage agreeent); 
> ##D # instead, obtain the kml file via a web browser, and save it to the working directory:
> ##D r <- readKML.GBIFdensity(kml.file)
> ##D class(r)
> ##D summary(r)
> ##D image(r)
> ##D # add world borders:
> ##D library(maps)
> ##D country.m = map('world', plot=FALSE, fill=TRUE)
> ##D IDs <- sapply(strsplit(country.m$names, ":"), function(x) x[1])
> ##D library(maptools)
> ##D country <- as(map2SpatialPolygons(country.m, IDs=IDs), "SpatialLines")
> ##D lines(country)
> ##D # to import a list of files, use e.g.:
> ##D kml.list <- list(kml.file)
> ##D r.lst <- lapply(kml.list, readKML.GBIFdensity, silent = TRUE)
> ##D # mask out missing layers (empty KML files):
> ##D mask <- !sapply(r.lst, is.null)
> ##D r.lst <- brick(r.lst[mask])
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("readKML.GBIFdensity", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("reproject")
> ### * reproject
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: reproject
> ### Title: Methods to reproject maps to a referent coordinate system
> ###   (WGS84)
> ### Aliases: reproject reproject.RasterBrick reproject.RasterLayer
> ###   reproject.RasterStack reproject.SpatialGrid reproject.SpatialPoints
> ###   reproject,SpatialLines-method reproject,SpatialPoints-method
> ###   reproject,SpatialPixelsDataFrame-method
> ###   reproject,SpatialPixelsDataFrame-method
> ###   reproject,SpatialPolygons-method
> ###   reproject,SpatialGridDataFrame-method reproject,RasterStack-method
> ###   reproject,RasterLayer-method reproject,RasterBrick-method
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## example with vector data:
> data(eberg)
> library(sp)
> library(rgdal)
rgdal: version: 1.3-3, (SVN revision 759)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 2.2.3, released 2017/11/20
 Path to GDAL shared files: /usr/share/gdal/2.2
 GDAL binary built with GEOS: TRUE 
 Loaded PROJ.4 runtime: Rel. 4.9.3, 15 August 2016, [PJ_VERSION: 493]
 Path to PROJ.4 shared files: (autodetected)
 Linking to sp version: 1.3-1 
> coordinates(eberg) <- ~X+Y
> proj4string(eberg) <- CRS("+init=epsg:31467")
> eberg.geo <- reproject(eberg)
Reprojecting to +proj=longlat +datum=WGS84 ...
> ## Not run: 
> ##D ## example with raster data:
> ##D data(eberg_grid25)
> ##D gridded(eberg_grid25) <- ~x+y
> ##D proj4string(eberg_grid25) <- CRS("+init=epsg:31467")
> ##D ## reproject to geographical coords (can take few minutes!):
> ##D eberg_grid_ll <- reproject(eberg_grid25[1])
> ##D ## much faster when using GDAL:
> ##D eberg_grid_ll2 <- reproject(eberg_grid25[1], program = "GDAL")
> ##D ## optional: compare processing times:
> ##D system.time(eberg_grid_ll <- reproject(eberg_grid25[1]))
> ##D system.time(eberg_grid_ll2 <- reproject(eberg_grid25[1], program="GDAL"))
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("reproject", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:rgdal’, ‘package:sp’

> nameEx("spMetadata")
> ### * spMetadata
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: spMetadata-methods
> ### Title: Methods to generate spatial metadata
> ### Aliases: spMetadata spMetadata,RasterLayer-method
> ###   spMetadata,Spatial-method spMetadata.Raster spMetadata.Spatial
> ###   metadata metadata.env read.metadata
> ### Keywords: spatial methods
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(sp)
> ##D library(uuid)
> ##D library(rjson)
> ##D ## read metadata from the system file:
> ##D x <- read.metadata(system.file("FGDC.xml", package="plotKML"))
> ##D str(x)
> ##D ## generate missing metadata
> ##D data(eberg)
> ##D coordinates(eberg) <- ~X+Y
> ##D proj4string(eberg) <- CRS("+init=epsg:31467")
> ##D ## no metadata file specified:
> ##D eberg.md <- spMetadata(eberg["SNDMHT_A"])
> ##D ## this generates some metadata automatically e.g.:
> ##D xmlRoot(eberg.md@xml)[["eainfo"]][["detailed"]][["attr"]]
> ##D ## combine with localy prepared metadata file:
> ##D eberg.md <- spMetadata(eberg["SNDMHT_A"], 
> ##D     xml.file=system.file("eberg.xml", package="plotKML"))
> ##D ## Additional metadat entries can be added by using e.g.:
> ##D eberg.md <- spMetadata(eberg["SNDMHT_A"], 
> ##D   md.type="INSPIRE", 
> ##D   CI_Citation_title = 'Ebergotzen data set',
> ##D   CI_Online_resource_URL = 'http://geomorphometry.org/content/ebergotzen')
> ##D ## the same using the FGDC template:
> ##D eberg.md <- spMetadata(eberg["SNDMHT_A"], 
> ##D   Citation_title = 'Ebergotzen data set',
> ##D   Citation_URL = 'http://geomorphometry.org/content/ebergotzen')
> ##D ## Complete list of names:
> ##D mdnames <- read.csv(system.file("mdnames.csv", package="plotKML"))
> ##D mdnames$field.names
> ##D ## these can be assigned to the "metadata" environment by using:
> ##D metadata.env(CI_Citation_title = 'Ebergotzen data set')
> ##D get("CI_Citation_title", metadata)
> ##D 
> ##D ## write data and metadata to a file:
> ##D library(rgdal)
> ##D writeOGR(eberg["SNDMHT_A"], "eberg_SAND.shp", ".", "ESRI Shapefile")
> ##D saveXML(eberg.md@xml, "eberg_SAND.xml")
> ##D ## export to SLD format:
> ##D metadata2SLD(eberg.md, "eberg.sld")
> ##D ## plot the layer with the metadata:
> ##D kml(eberg, file.name = "eberg_md.kml", colour = SNDMHT_A, metadata = eberg.md, kmz = TRUE)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("spMetadata", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("spPhoto")
> ### * spPhoto
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: spPhoto
> ### Title: Generate an object of class '"SpatialPhotoOverlay"'
> ### Aliases: spPhoto SpatialPhotoOverlay
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # two examples with images on Wikimedia Commons
> ##D # (1) soil monolith (manually entered coordinates):
> ##D imagename = "Soil_monolith.jpg"
> ##D # import EXIF data using the Wikimedia API:
> ##D x1 <- getWikiMedia.ImageInfo(imagename)
> ##D # create a SpatialPhotoOverlay:
> ##D sm <- spPhoto(filename = x1$url$url, exif.info = x1$metadata)
> ##D # plot it in Google Earth
> ##D kml(sm, method="monolith", kmz=TRUE)
> ##D # (2) PhotoOverlay (geotagged photo):
> ##D imagename = "Africa_Museum_Nijmegen.jpg"
> ##D x2 <- getWikiMedia.ImageInfo(imagename)
> ##D af <- spPhoto(filename = x2$url$url, exif.info = x2$metadata)
> ##D kml(af)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("spPhoto", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("vect2rast")
> ### * vect2rast
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: vect2rast
> ### Title: Convert points, lines and/or polygons to rasters
> ### Aliases: vect2rast vect2rast,SpatialPoints-method
> ###   vect2rast.SpatialLines vect2rast,SpatialLines-method
> ###   vect2rast.SpatialPolygons vect2rast,SpatialPolygons-method rasterize
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(eberg)
> ##D library(sp)
> ##D library(maptools)
> ##D library(spatstat)
> ##D coordinates(eberg) <- ~X+Y
> ##D data(eberg_zones)
> ##D # point map:
> ##D x <- vect2rast(eberg, fname = "SNDMHT_A")
> ##D image(x)
> ##D # polygon map:
> ##D x <- vect2rast(eberg_zones)
> ##D image(x)
> ##D # for large data sets use SAGA GIS:
> ##D x <- vect2rast(eberg_zones, method = "SAGA")
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("vect2rast", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("vect2rast.SpatialPoints")
> ### * vect2rast.SpatialPoints
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: vect2rast.SpatialPoints
> ### Title: Converts points to rasters
> ### Aliases: vect2rast.SpatialPoints
> ### Keywords: spatial
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(sp)
> ##D data(meuse)
> ##D coordinates(meuse) <- ~x+y
> ##D # point map:
> ##D x <- vect2rast(meuse, fname = "om")
> ##D data(SAGA_pal)
> ##D sp.p <- list("sp.points", meuse, pch="+", cex=1.5, col="black")
> ##D spplot(x, col.regions=SAGA_pal[[1]], sp.layout=sp.p)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("vect2rast.SpatialPoints", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("whitening")
> ### * whitening
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: whitening
> ### Title: whitening
> ### Aliases: whitening
> 
> ### ** Examples
> 
> whitening(z=15, zvar=5, zlim=c(10,20), global.var=7)
             R         G         B
[1,] 0.6461873 0.8709619 0.6461873
> # significant color;
> whitening(z=15, zvar=5, zlim=c(10,20), global.var=4)
     R G B
[1,] 1 1 1
> # error exceeds global.var -> totally white;
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("whitening", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("worldgrids_pal")
> ### * worldgrids_pal
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: worldgrids_pal
> ### Title: Standard global color palettes for factor variables
> ### Aliases: worldgrids_pal
> ### Keywords: color
> 
> ### ** Examples
> 
> data(worldgrids_pal)
> ## Not run: 
> ##D # globcov palette with class names:
> ##D display.pal(worldgrids_pal)
> ##D dev.off()
> ##D display.pal(worldgrids_pal, sel=5, names=TRUE)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("worldgrids_pal", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  6.952 0.292 7.428 0.267 0.02 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
