<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>R: Methods for plotting results of spatial analysis in Google...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="R.css">
</head><body>

<table width="100%" summary="page for plotKML-method {plotKML}"><tr><td>plotKML-method {plotKML}</td><td align="right">R Documentation</td></tr></table>

<h2>Methods for plotting results of spatial analysis in Google Earth</h2>

<h3>Description</h3>

<p>The method writes inputs and outputs of spatial analysis (a list of point, gridded and/or polygon data usually) to KML and opens the KML file in Google Earth (or any other default package used to view KML/KMZ files).</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'SpatialPointsDataFrame'
plotKML(obj, 
      folder.name = normalizeFilename(deparse(substitute(obj, env = parent.frame()))),
      file.name = paste(folder.name, ".kml", sep=""), 
      size, colour, points_names, 
      shape = "http://maps.google.com/mapfiles/kml/pal2/icon18.png", 
      metadata = NULL, kmz = get("kmz", envir = plotKML.opts), open.kml = TRUE, ...)
## S4 method for signature 'SpatialLinesDataFrame'
plotKML(obj, 
      folder.name = normalizeFilename(deparse(substitute(obj, env = parent.frame()))), 
      file.name = paste(folder.name, ".kml", sep=""),
      metadata = NULL, kmz = get("kmz", envir = plotKML.opts), open.kml = TRUE, ...)
## S4 method for signature 'SpatialPolygonsDataFrame'
plotKML(obj, 
      folder.name = normalizeFilename(deparse(substitute(obj, env = parent.frame()))), 
      file.name = paste(folder.name, ".kml", sep=""), 
      colour, plot.labpt, labels, metadata = NULL, 
      kmz = get("kmz", envir = plotKML.opts), open.kml = TRUE, ...)
## S4 method for signature 'SpatialPixelsDataFrame'
plotKML(obj, 
      folder.name = normalizeFilename(deparse(substitute(obj, env = parent.frame()))), 
      file.name = paste(folder.name, ".kml", sep=""), 
      colour, raster_name, metadata = NULL, kmz = FALSE, open.kml = TRUE, ...)
## S4 method for signature 'SpatialGridDataFrame'
plotKML(obj, 
      folder.name = normalizeFilename(deparse(substitute(obj, env = parent.frame()))), 
      file.name = paste(folder.name, ".kml", sep=""), 
      colour, raster_name, metadata = NULL, kmz = FALSE, open.kml = TRUE, ...)
## S4 method for signature 'RasterLayer'
plotKML(obj, 
      folder.name = normalizeFilename(deparse(substitute(obj, env = parent.frame()))), 
      file.name = paste(folder.name, ".kml", sep=""), 
      colour, raster_name, metadata = NULL, kmz = FALSE, open.kml = TRUE, ...)
## S4 method for signature 'SpatialPhotoOverlay'
plotKML(obj, 
      folder.name = normalizeFilename(deparse(substitute(obj, env = parent.frame()))), 
      file.name = paste(folder.name, ".kml", sep=""), 
      dae.name, kmz = get("kmz", envir = plotKML.opts), open.kml = TRUE, ...)
## S4 method for signature 'SoilProfileCollection'
plotKML(obj, 
      folder.name = normalizeFilename(deparse(substitute(obj, env = parent.frame()))), 
      file.name = paste(folder.name, ".kml", sep=""), 
      var.name, metadata = NULL, kmz = get("kmz", envir = plotKML.opts), 
      open.kml = TRUE, ...)
## S4 method for signature 'STIDF'
plotKML(obj, 
      folder.name = normalizeFilename(deparse(substitute(obj, env = parent.frame()))), 
      file.name = paste(folder.name, ".kml", sep=""), 
      colour, shape = "http://maps.google.com/mapfiles/kml/pal2/icon18.png", 
      points_names, kmz = get("kmz", envir = plotKML.opts), open.kml = TRUE, ...)
## S4 method for signature 'STFDF'
plotKML(obj, ...)
## S4 method for signature 'STSDF'
plotKML(obj, ...)
## S4 method for signature 'STTDF'
plotKML(obj, 
      folder.name = normalizeFilename(deparse(substitute(obj, env = parent.frame()))), 
      file.name = paste(folder.name, ".kml", sep=""), 
      colour, start.icon = "http://maps.google.com/mapfiles/kml/pal2/icon18.png", 
      kmz = get("kmz", envir = plotKML.opts), open.kml = TRUE, ...)
## S4 method for signature 'RasterBrickTimeSeries'
plotKML(obj, 
      folder.name = normalizeFilename(deparse(substitute(obj, env = parent.frame()))), 
      file.name = paste(folder.name, ".kml", sep=""),
      pngwidth = 680, pngheight = 180, pngpointsize = 14, 
      kmz = get("kmz", envir = plotKML.opts), open.kml = TRUE, ...)
## S4 method for signature 'RasterBrickSimulations'
plotKML(obj, 
      folder.name = normalizeFilename(deparse(substitute(obj, env = parent.frame()))), 
      file.name = paste(folder.name, ".kml", sep=""), 
      obj.summary = TRUE,
      pngwidth = 680, pngheight = 200, pngpointsize = 14, 
      kmz = get("kmz", envir = plotKML.opts), open.kml = TRUE, ...)
## S4 method for signature 'SpatialMaxEntOutput'
plotKML(obj, 
      folder.name = normalizeFilename(deparse(substitute(obj, env = parent.frame()))), 
      file.name = paste(folder.name, ".kml", sep=""), 
      html.file = obj@maxent@html, 
      iframe.width = 800, iframe.height = 800, pngwidth = 280, 
      pngheight = 280, pngpointsize = 14, colour, 
      shape = "http://plotkml.r-forge.r-project.org/icon17.png", 
      kmz = get("kmz", envir = plotKML.opts), open.kml = TRUE, 
      TimeSpan.begin = obj@TimeSpan.begin, TimeSpan.end = obj@TimeSpan.end, ...)
## S4 method for signature 'SpatialPredictions'
plotKML(obj, 
      folder.name = normalizeFilename(deparse(substitute(obj, env = parent.frame()))), 
      file.name = paste(folder.name, ".kml", sep=""), colour, 
      scale_svar = get("colour_scale_svar", envir = plotKML.opts), 
      grid2poly = FALSE, obj.summary = TRUE, plot.svar = FALSE, 
      pngwidth = 210, pngheight = 580, pngpointsize = 14, 
      metadata = NULL, kmz = get("kmz", envir = plotKML.opts), open.kml = TRUE, ...)
## S4 method for signature 'SpatialSamplingPattern'
plotKML(obj, 
      folder.name = normalizeFilename(deparse(substitute(obj, env = parent.frame()))), 
      file.name = paste(folder.name, ".kml", sep=""),
      colour, kmz = get("kmz", envir = plotKML.opts), open.kml = TRUE, ...)
## S4 method for signature 'SpatialVectorsSimulations'
plotKML(obj, 
      folder.name = normalizeFilename(deparse(substitute(obj, env = parent.frame()))), 
      file.name = paste(folder.name, ".kml", sep=""), colour, 
      scale_svar = get("colour_scale_svar", envir = plotKML.opts), 
      grid2poly = FALSE, obj.summary = TRUE, plot.svar = FALSE, 
      kmz = get("kmz", envir = plotKML.opts), open.kml = TRUE, ...)
## S4 method for signature 'list'
plotKML(obj, 
      folder.name = normalizeFilename(deparse(substitute(obj, env=parent.frame()))),
      file.name = paste(folder.name, ".kml", sep=""), 
      size = NULL, colour, points_names = "",
      shape = "http://maps.google.com/mapfiles/kml/pal2/icon18.png",
      plot.labpt = TRUE, labels = "", metadata = NULL, 
      kmz = get("kmz", envir = plotKML.opts), open.kml = TRUE, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>obj</code></td>
<td>
<p>input object of specific class; either some <a href="http://cran.r-project.org/package=sp">sp</a>, or <a href="http://cran.r-project.org/package=raster">raster</a> or <a href="http://cran.r-project.org/package=spacetime">spacetime</a> package class object, or plotKML composite objects containing both inputs and outputs of analysis</p>
</td></tr>
<tr valign="top"><td><code>folder.name</code></td>
<td>
<p>character; folder name in the KML file</p>
</td></tr>
<tr valign="top"><td><code>file.name</code></td>
<td>
<p>character; output KML file name</p>
</td></tr>
<tr valign="top"><td><code>size</code></td>
<td>
<p>for point objects for plotting (see <a href="aesthetics.html">aesthetics</a>)</p>
</td></tr>
<tr valign="top"><td><code>colour</code></td>
<td>
<p>colour variable for plotting (see <a href="aesthetics.html">aesthetics</a>)</p>
</td></tr>
<tr valign="top"><td><code>points_names</code></td>
<td>
<p>vector of characters that can be used as labels</p>
</td></tr>
<tr valign="top"><td><code>shape</code></td>
<td>
<p>character; icons used for plotting (see <a href="aesthetics.html">aesthetics</a>)</p>
</td></tr>
<tr valign="top"><td><code>raster_name</code></td>
<td>
<p>(optional) specify the output file name (PNG)</p>
</td></tr>
<tr valign="top"><td><code>var.name</code></td>
<td>
<p>target variable name (only valid for visualization of <code>"SoilProfileCollection"</code> class data</p>
</td></tr>
<tr valign="top"><td><code>metadata</code></td>
<td>
<p>(optional) the metadata object</p>
</td></tr>
<tr valign="top"><td><code>plot.labpt</code></td>
<td>
<p>logical; specifies whether to plot centroids for polygon data</p>
</td></tr>
<tr valign="top"><td><code>labels</code></td>
<td>
<p>character vector; list of labels that will attached to the centroids</p>
</td></tr>
<tr valign="top"><td><code>start.icon</code></td>
<td>
<p>icon for the start position (for trajectory data)</p>
</td></tr>
<tr valign="top"><td><code>dae.name</code></td>
<td>
<p>output DAE file name</p>
</td></tr>
<tr valign="top"><td><code>html.file</code></td>
<td>
<p>specify the location of the html file containing report data (if the input object is of class <code>"SpatialMaxEntOutput"</code>)</p>
</td></tr>
<tr valign="top"><td><code>iframe.width</code></td>
<td>
<p>integer; width of the screen for iframe</p>
</td></tr>
<tr valign="top"><td><code>iframe.height</code></td>
<td>
<p>integer; height of the screen for iframe</p>
</td></tr>
<tr valign="top"><td><code>TimeSpan.begin</code></td>
<td>
<p>object of class <code>"POSIXct"</code>; begin of the sampling period</p>
</td></tr>
<tr valign="top"><td><code>TimeSpan.end</code></td>
<td>
<p>object of class <code>"POSIXct"</code>; end of the sampling period</p>
</td></tr>
<tr valign="top"><td><code>pngwidth</code></td>
<td>
<p>integer; width of the PNG plot (screen image)</p>
</td></tr>
<tr valign="top"><td><code>pngheight</code></td>
<td>
<p>integer; height of the PNG plot (screen image)</p>
</td></tr>
<tr valign="top"><td><code>pngpointsize</code></td>
<td>
<p>integer; text size in the PNG plot (screen image)</p>
</td></tr>
<tr valign="top"><td><code>scale_svar</code></td>
<td>
<p>colour palette for the model uncertainty (usually standardized prediction variance)</p>
</td></tr>
<tr valign="top"><td><code>grid2poly</code></td>
<td>
<p>logical; specifies whether to convert gridded object to polygons</p>
</td></tr>
<tr valign="top"><td><code>obj.summary</code></td>
<td>
<p>logical; specifies whether to print the object summary</p>
</td></tr>
<tr valign="top"><td><code>plot.svar</code></td>
<td>
<p>logical; specifies whether to plot the model uncertainty</p>
</td></tr>
<tr valign="top"><td><code>kmz</code></td>
<td>
<p>logical; specifies whether to compress the output KML file</p>
</td></tr>
<tr valign="top"><td><code>open.kml</code></td>
<td>
<p>logical; specifies whether to directly open the output KML file (i.e. in Google Earth)</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>(optional) arguments passed to the lower level functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function to plot various spatial and spatio-temporal R objects that contain both inputs and outputs of spatial analysis. The resulting plots (referred to as <EM>&lsquo;views&rsquo;</EM>) are expected to be cartographically complete as they should contain legends, and data and model descriptions. In principle, <code>plotKML</code> works with both simple spatial objects, and complex objects such as <code>"SpatialPredictions"</code>, <code>"SpatialVectorsSimulations"</code>, <code>"RasterBrickSimulations"</code>, <code>"RasterBrickTimeSeries"</code>, <code>"SpatialMaxEntOutput"</code> and similar. To further customize visualizations consider combining the lower level functions <code><a href="kml_open.html">kml_open</a></code>, <code><a href="kml_open.html">kml_close</a></code>, <code><a href="kml_compress.html">kml_compress</a></code>, <code><a href="kml_screen.html">kml_screen</a></code> into your own <code>plotKML()</code> method.
</p>
<p>All ST-classes are coerced to the STIDF format and hence use the plotKML method for STIDFs.
</p>


<h3>Note</h3>

<p>To prepare a list of objects of class <code>"SpatialPointsDataFrame"</code>, <code>"SpatialLinesDataFrame"</code>, <code>"SpatialPolygonsDataFrame"</code>, or <code>"SpatialPixelsDataFrame"</code> consider using the <code>GSIF::tile</code> function. Writting large spatial objects via plotKML can be time consuming. Please refer to the package manual for more information.
</p>


<h3>See Also</h3>

 <p><code><a href="SpatialPredictions.html">SpatialPredictions-class</a></code>, <code><a href="SpatialVectorsSimulations.html">SpatialVectorsSimulations-class</a></code>, <code><a href="RasterBrickSimulations.html">RasterBrickSimulations-class</a></code>, <code><a href="RasterBrickTimeSeries.html">RasterBrickTimeSeries-class</a></code>, <code><a href="SpatialMaxEntOutput.html">SpatialMaxEntOutput-class</a></code>, <code><a href="SpatialSamplingPattern.html">SpatialSamplingPattern-class</a></code>   
</p>


<h3>Examples</h3>

<pre>
plotKML.env(silent = FALSE, kmz = FALSE)
## -------------- SpatialPointsDataFrame --------- ##
library(sp)
library(rgdal)
data(eberg)
coordinates(eberg) &lt;- ~X+Y
proj4string(eberg) &lt;- CRS("+init=epsg:31467")
## subset to 20 percent:
eberg &lt;- eberg[runif(nrow(eberg))&lt;.1,]
## Not run: ## bubble type plot:
plotKML(eberg["CLYMHT_A"])
plotKML(eberg["CLYMHT_A"], colour_scale=rep("#FFFF00", 2), points_names="")

## End(Not run)
## plot points with a legend:
shape = "http://maps.google.com/mapfiles/kml/pal2/icon18.png" 
kml_open("eberg_CLYMHT_A.kml")
kml_layer(eberg["CLYMHT_A"], colour=CLYMHT_A, z.lim=c(20,60),
   colour_scale=SAGA_pal[[1]], shape=shape, points_names="")
kml_legend.bar(x=eberg$CLYMHT_A, legend.file="kml_legend.png",
   legend.pal=SAGA_pal[[1]], z.lim=c(20,60))
kml_screen(image.file="kml_legend.png")
kml_close("eberg_CLYMHT_A.kml")

## -------------- SpatialLinesDataFrame --------- ##
data(eberg_contours)
## Not run: 
plotKML(eberg_contours)
## plot contour lines with actual altitudes:
plotKML(eberg_contours, colour=Z, altitude=Z)

## End(Not run)

## -------------- SpatialPolygonsDataFrame --------- ##
data(eberg_zones)
## Not run: 
plotKML(eberg_zones["ZONES"])
## add altitude:
zmin = 230
plotKML(eberg_zones["ZONES"], altitude=zmin+runif(length(eberg_zones))*500)

## End(Not run)

## -------------- SpatialPixelsDataFrame --------- ##
library(rgdal)
library(raster)
data(eberg_grid)
gridded(eberg_grid) &lt;- ~x+y
proj4string(eberg_grid) &lt;- CRS("+init=epsg:31467")
TWI &lt;- reproject(eberg_grid["TWISRT6"])
data(SAGA_pal)
## Not run: ## set limits manually (increase resolution):
plotKML(TWI, colour_scale = SAGA_pal[[1]])
plotKML(TWI, z.lim=c(12,20), colour_scale = SAGA_pal[[1]])

## End(Not run)
## categorical data:
eberg_grid$LNCCOR6 &lt;- as.factor(paste(eberg_grid$LNCCOR6))
levels(eberg_grid$LNCCOR6)
data(worldgrids_pal)
## attr(worldgrids_pal["corine2k"][[1]], "names")
pal = as.character(worldgrids_pal["corine2k"][[1]][c(1,11,13,14,16,17,18)])
LNCCOR6 &lt;- reproject(eberg_grid["LNCCOR6"])
## Not run: 
plotKML(LNCCOR6, colour_scale=pal)

## End(Not run)

## -------------- SpatialPhotoOverlay --------- ##
## Not run: 
library(RCurl)
imagename = "Soil_monolith.jpg"
urlExists = url.exists("http://commons.wikimedia.org")
if(urlExists){
  x1 &lt;- getWikiMedia.ImageInfo(imagename)
  sm &lt;- spPhoto(filename = x1$url$url, exif.info = x1$metadata)
  # str(sm)
  plotKML(sm)
}

## End(Not run)

## -------------- SoilProfileCollection --------- ##
library(aqp)
library(plyr)
## sample profile from Nigeria:
lon = 3.90; lat = 7.50; id = "ISRIC:NG0017"; FAO1988 = "LXp" 
top = c(0, 18, 36, 65, 87, 127) 
bottom = c(18, 36, 65, 87, 127, 181)
ORCDRC = c(18.4, 4.4, 3.6, 3.6, 3.2, 1.2)
hue = c("7.5YR", "7.5YR", "2.5YR", "5YR", "5YR", "10YR")
value = c(3, 4, 5, 5, 5, 7); chroma = c(2, 4, 6, 8, 4, 3)
## prepare a SoilProfileCollection:
prof1 &lt;- join(data.frame(id, top, bottom, ORCDRC, hue, value, chroma), 
   data.frame(id, lon, lat, FAO1988), type='inner')
prof1$soil_color &lt;- with(prof1, munsell2rgb(hue, value, chroma))
depths(prof1) &lt;- id ~ top + bottom
site(prof1) &lt;- ~ lon + lat + FAO1988 
coordinates(prof1) &lt;- ~ lon + lat
proj4string(prof1) &lt;- CRS("+proj=longlat +datum=WGS84")
prof1
## Not run: 
plotKML(prof1, var.name="ORCDRC", color.name="soil_color")

## End(Not run)

## -------------- STIDF --------- ##
library(sp)
library(spacetime)
## daily temperatures for Croatia:
data(HRtemp08)
## format the time column:
HRtemp08$ctime &lt;- as.POSIXct(HRtemp08$DATE, format="%Y-%m-%dT%H:%M:%SZ")
## create a STIDF object:
sp &lt;- SpatialPoints(HRtemp08[,c("Lon","Lat")])
proj4string(sp) &lt;- CRS("+proj=longlat +datum=WGS84")
HRtemp08.st &lt;- STIDF(sp, time = HRtemp08$ctime, data = HRtemp08[,c("NAME","TEMP")])
## subset to first 500 records:
HRtemp08_jan &lt;- HRtemp08.st[1:500]
str(HRtemp08_jan)
## Not run: 
plotKML(HRtemp08_jan[,,"TEMP"], LabelScale = .4)

## End(Not run)

## foot-and-mouth disease data:
data(fmd)
fmd0  &lt;- data.frame(fmd)
coordinates(fmd0) &lt;- c("X", "Y")
proj4string(fmd0) &lt;- CRS("+init=epsg:27700")
fmd_sp &lt;- as(fmd0, "SpatialPoints")
dates &lt;- as.Date("2001-02-18")+fmd0$ReportedDay
library(spacetime)
fmd_ST &lt;- STIDF(fmd_sp, dates, data.frame(ReportedDay=fmd0$ReportedDay))
data(SAGA_pal)
## Not run: 
plotKML(fmd_ST, colour_scale=SAGA_pal[[1]])

## End(Not run)

## -------------- STFDF --------- ##

## results of krigeST:
library(gstat)
library(sp)
library(spacetime)
library(raster)
## define space-time variogram
sumMetricVgm &lt;- vgmST("sumMetric",
                      space=vgm( 4.4, "Lin", 196.6,  3),
                      time =vgm( 2.2, "Lin",   1.1,  2),
                      joint=vgm(34.6, "Exp", 136.6, 12),
                      stAni=51.7)
## example from the gstat package:
data(air)
rr &lt;- rural[,"2005-06-01/2005-06-03"]
rr &lt;- as(rr,"STSDF")
x1 &lt;- seq(from=6,to=15,by=1)
x2 &lt;- seq(from=48,to=55,by=1)
DE_gridded &lt;- SpatialPoints(cbind(rep(x1,length(x2)), rep(x2,each=length(x1))), 
                           proj4string=CRS(proj4string(rr@sp)))
gridded(DE_gridded) &lt;- TRUE
DE_pred &lt;- STF(sp=as(DE_gridded,"SpatialPoints"), time=rr@time)
DE_kriged &lt;- krigeST(PM10~1, data=rr, newdata=DE_pred,
                     modelList=sumMetricVgm)
gridded(DE_kriged@sp) &lt;- TRUE
stplot(DE_kriged)
## plot in Google Earth:
z.lim = range(DE_kriged@data, na.rm=TRUE)
## Not run: 
plotKML(DE_kriged, z.lim=z.lim)
## add observations points:
plotKML(rr, z.lim=z.lim)

## End(Not run)

## -------------- STTDF --------- ##
## Not run: 
library(fossil)
library(spacetime)
library(adehabitat)
data(gpxbtour)
## format the time column:
gpxbtour$ctime &lt;- as.POSIXct(gpxbtour$time, format="%Y-%m-%dT%H:%M:%SZ")
coordinates(gpxbtour) &lt;- ~lon+lat
proj4string(gpxbtour) &lt;- CRS("+proj=longlat +datum=WGS84")
xy &lt;- as.list(data.frame(t(coordinates(gpxbtour))))
gpxbtour$dist.km &lt;- sapply(xy, function(x) { 
  deg.dist(long1=x[1], lat1=x[2], long2=xy[[1]][1], lat2=xy[[1]][2]) 
} )
## convert to a STTDF class:
gpx.ltraj &lt;- as.ltraj(coordinates(gpxbtour), gpxbtour$ctime, id = "th")
gpx.st &lt;- as(gpx.ltraj, "STTDF")
gpx.st$speed &lt;- gpxbtour$speed
gpx.st@sp@proj4string &lt;- CRS("+proj=longlat +datum=WGS84")
str(gpx.st)
plotKML(gpx.st, colour="speed")

## End(Not run)

## -------------- Spatial Metadata --------- ##
## Not run: 
eberg.md &lt;- spMetadata(eberg, xml.file=system.file("eberg.xml", package="plotKML"),
  Target_variable="SNDMHT_A", Citation_title="Ebergotzen profiles")
plotKML(eberg[1:100,"CLYMHT_A"], metadata=eberg.md)

## End(Not run)

## -------------- RasterBrickTimeSeries --------- ##
library(raster)
library(sp)
data(LST)
gridded(LST) &lt;- ~lon+lat
proj4string(LST) &lt;- CRS("+proj=longlat +datum=WGS84")
dates &lt;- sapply(strsplit(names(LST), "LST"), function(x){x[[2]]})
datesf &lt;- format(as.Date(dates, "%Y_%m_%d"), "%Y-%m-%dT%H:%M:%SZ")
## begin / end dates +/- 4 days:
TimeSpan.begin = as.POSIXct(unclass(as.POSIXct(datesf))-4*24*60*60, origin="1970-01-01") 
TimeSpan.end = as.POSIXct(unclass(as.POSIXct(datesf))+4*24*60*60, origin="1970-01-01")
## pick climatic stations in the area:
pnts &lt;- HRtemp08[which(HRtemp08$NAME=="Pazin")[1],]
pnts &lt;- rbind(pnts, HRtemp08[which(HRtemp08$NAME=="Crni Lug - NP Risnjak")[1],])
pnts &lt;- rbind(pnts, HRtemp08[which(HRtemp08$NAME=="Cres")[1],])
coordinates(pnts) &lt;- ~Lon + Lat
proj4string(pnts) &lt;- CRS("+proj=longlat +datum=WGS84")
## get the dates from the file names:
LST_ll &lt;- brick(LST[1:5])
LST_ll@title = "Time series of MODIS Land Surface Temperature images"
LST.ts &lt;- new("RasterBrickTimeSeries", variable = "LST", sampled = pnts, 
    rasters = LST_ll, TimeSpan.begin = TimeSpan.begin[1:5], 
    TimeSpan.end = TimeSpan.end[1:5])
data(SAGA_pal)
## Not run: ## plot MODIS images in Google Earth:
plotKML(LST.ts, colour_scale=SAGA_pal[[1]])

## End(Not run)

## -------------- Spatial Predictions --------- ##
library(sp)
library(rgdal)
library(gstat)
data(meuse)
coordinates(meuse) &lt;- ~x+y
proj4string(meuse) &lt;- CRS("+init=epsg:28992")
## load grids:
data(meuse.grid)
gridded(meuse.grid) &lt;- ~x+y
proj4string(meuse.grid) &lt;- CRS("+init=epsg:28992")
## Not run: ## fit a model:
library(GSIF)
omm &lt;- fit.gstatModel(observations = meuse, formulaString = om~dist, 
   family = gaussian(log), covariates = meuse.grid)
## produce SpatialPredictions:
om.rk &lt;- predict(omm, predictionLocations = meuse.grid)
## plot the whole geostatical mapping project in Google Earth:
plotKML(om.rk, colour_scale = SAGA_pal[[1]])
## plot each cell as polygon:
plotKML(om.rk, colour_scale = SAGA_pal[[1]], grid2poly = TRUE)

## End(Not run)

## -------------- SpatialSamplingPattern --------- ##
## Not run: 
library(spcosa)
library(sp)
## read a polygon map:
shpFarmsum &lt;- readOGR(dsn = system.file("maps", package = "spcosa"), 
  layer = "farmsum")
## stratify `Farmsum' into 50 strata
myStratification &lt;- stratify(shpFarmsum, nStrata = 50)
## sample two sampling units per stratum
mySamplingPattern &lt;- spsample(myStratification, n = 2)
## attach the correct proj4 string:
library(RCurl)
urlExists = url.exists("http://spatialreference.org/ref/sr-org/6781/proj4/")
if(urlExists){
  nl.rd &lt;- getURL("http://spatialreference.org/ref/sr-org/6781/proj4/")
  proj4string(mySamplingPattern@sample) &lt;- CRS(nl.rd) 
  # prepare spatial domain (polygons):
  sp.domain &lt;- as(myStratification@cells, "SpatialPolygons")
  sp.domain &lt;- SpatialPolygonsDataFrame(sp.domain, 
     data.frame(ID=as.factor(myStratification@stratumId)), match.ID = FALSE)
  proj4string(sp.domain) &lt;- CRS(nl.rd) 
  # create new object:
  mySamplingPattern.ssp &lt;- new("SpatialSamplingPattern", 
     method = class(mySamplingPattern), pattern = mySamplingPattern@sample, 
     sp.domain = sp.domain)
  # the same plot now in Google Earth:
  shape = "http://maps.google.com/mapfiles/kml/pal2/icon18.png"
  plotKML(mySamplingPattern.ssp, shape = shape)
}

## End(Not run)

## -------------- RasterBrickSimulations --------- ##
## Not run: 
library(sp)
library(gstat)
data(barxyz)
## define the projection system:
prj = "+proj=tmerc +lat_0=0 +lon_0=18 +k=0.9999 +x_0=6500000 +y_0=0 
  +ellps=bessel +units=m 
  +towgs84=550.499,164.116,475.142,5.80967,2.07902,-11.62386,0.99999445824"
coordinates(barxyz) &lt;- ~x+y
proj4string(barxyz) &lt;- CRS(prj)
data(bargrid)
coordinates(bargrid) &lt;- ~x+y
gridded(bargrid) &lt;- TRUE
proj4string(bargrid) &lt;- CRS(prj)
## fit a variogram and generate simulations:
Z.ovgm &lt;- vgm(psill=1352, model="Mat", range=650, nugget=0, kappa=1.2)
sel &lt;- runif(length(barxyz$Z))&lt;.2  
## Note: this operation can be time consuming
sims &lt;- krige(Z~1, barxyz[sel,], bargrid, model=Z.ovgm, nmax=20, 
   nsim=10, debug.level=-1)
## specify the cross-section:
t1 &lt;- Line(matrix(c(bargrid@bbox[1,1], bargrid@bbox[1,2], 5073012, 5073012), ncol=2))
transect &lt;- SpatialLines(list(Lines(list(t1), ID="t")), CRS(prj))
## glue to a RasterBrickSimulations object:
library(raster)
bardem_sims &lt;- new("RasterBrickSimulations", variable = "elevations", 
  sampled = transect, realizations = brick(sims))
## plot the whole project and open in Google Earth:
data(R_pal)
plotKML(bardem_sims, colour_scale = R_pal[[4]])

## End(Not run)

## -------------- SpatialVectorsSimulations --------- ##
## Not run: 
data(barstr)
data(bargrid)
library(sp)
coordinates(bargrid) &lt;- ~ x+y
gridded(bargrid) &lt;- TRUE
## output topology:
cell.size = bargrid@grid@cellsize[1]
bbox = bargrid@bbox
nrows = round(abs(diff(bbox[1,])/cell.size), 0) 
ncols = round(abs(diff(bbox[2,])/cell.size), 0)
gridT = GridTopology(cellcentre.offset=bbox[,1], 
  cellsize=c(cell.size,cell.size), 
  cells.dim=c(nrows, ncols))
bar_sum &lt;- count.GridTopology(gridT, vectL=barstr[1:5])
## NOTE: this operation can be time consuming!
## plot the whole project and open in Google Earth:
plotKML(bar_sum)

## End(Not run)

## -------------- SpatialMaxEntOutput --------- ##
## Not run: 
library(maptools)
library(rgdal)
data(bigfoot)
aea.prj &lt;- "+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 
   +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs"
data(USAWgrids)
gridded(USAWgrids) &lt;- ~s1+s2
proj4string(USAWgrids) &lt;- CRS(aea.prj)
bbox &lt;- spTransform(USAWgrids, CRS("+proj=longlat +datum=WGS84"))@bbox
sel = bigfoot$Lon &gt; bbox[1,1] &amp; bigfoot$Lon &lt; bbox[1,2] &amp;
    bigfoot$Lat &gt; bbox[2,1] &amp; bigfoot$Lat &lt; bbox[2,2]
bigfoot &lt;- bigfoot[sel,]
coordinates(bigfoot) &lt;- ~Lon+Lat
proj4string(bigfoot) &lt;- CRS("+proj=longlat +datum=WGS84")
library(spatstat)
bigfoot.aea &lt;- as.ppp(spTransform(bigfoot, CRS(aea.prj)))
## Load the covariates:
sel.grids &lt;- c("globedem","nlights03","sdroads","gcarb","twi","globcov")
library(GSIF)
library(dismo)
## run MaxEnt analysis:
jar &lt;- paste(system.file(package="dismo"), "/java/maxent.jar", sep='')
if(file.exists(jar)){
  bigfoot.smo &lt;- MaxEnt(bigfoot.aea, USAWgrids[sel.grids])
  icon = "http://plotkml.r-forge.r-project.org/bigfoot.png"
  data(R_pal)
  plotKML(bigfoot.smo, colour_scale = R_pal[["bpy_colors"]], shape = icon)
}

## End(Not run)
</pre>

<hr><div align="center">[Package <em>plotKML</em> version 0.5-1 <a href="00Index.html">Index</a>]</div>
</body></html>
